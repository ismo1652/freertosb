% Exemplo de relatório técnico e outros documentos do DIMAp-UFRN
% com texto em português formatado com LaTeX

\documentclass[capa]{rt-dimap}
% Opções da classe rt-dimap
%   [capa]  -> Gerar a capa colorida do relatório técnico
%   [plain] -> Usar o estilo "plain" de citação bibliográfica
%\newcommand{\FreeRTOS}{\operatorname{\textit{FreeRTOS }}}

%% Keywords for the B method
\newcommand{\MACHINE}{\operatorname{\mathbf{MACHINE}}}
\newcommand{\REFINEMENT}{\operatorname{\mathbf{REFINEMENT}}}
\newcommand{\IMPLEMENTATION}{\operatorname{\mathbf{IMPLEMENTATION}}}
\newcommand{\REFINES}{\operatorname{\mathbf{REFINES}}}
\newcommand{\SEES}{\operatorname{\mathbf{SEES}}}
\newcommand{\IMPORTS}{\operatorname{\mathbf{IMPORTS}}}
\newcommand{\SETS}{\operatorname{\mathbf{SETS}}}
\newcommand{\CONSTANTS}{\operatorname{\mathbf{CONSTANTS}}}
\newcommand{\PROPERTIES}{\operatorname{\mathbf{PROPERTIES}}}
\newcommand{\VARIABLES}{\operatorname{\mathbf{VARIABLES}}}
\newcommand{\INVARIANT}{\operatorname{\mathbf{INVARIANT}}}
\newcommand{\INITIALISATION}{\operatorname{\mathbf{INITIALISATION}}}
\newcommand{\OPERATIONS}{\operatorname{\mathbf{OPERATIONS}}}
\newcommand{\BEGIN}{\operatorname{\mathbf{BEGIN}}}
\newcommand{\END}{\operatorname{\mathbf{END}}}
\newcommand{\PRE}{\operatorname{\mathbf{PRE}}}
\newcommand{\IF}{\operatorname{\mathbf{IF}}}
\newcommand{\THEN}{\operatorname{\mathbf{THEN}}}
\newcommand{\ELSE}{\operatorname{\mathbf{ELSE}}}
\newcommand{\ELSIF}{\operatorname{\mathbf{ELSIF}}}
\newcommand{\ANY}{\operatorname{\mathbf{ANY}}}
\newcommand{\WHERE}{\operatorname{\mathbf{WHERE}}}
\newcommand{\CASE}{\operatorname{\mathbf{CASE}}}
\newcommand{\OF}{\operatorname{\mathbf{OF}}}
\newcommand{\EITHER}{\operatorname{\mathbf{EITHER}}}
\newcommand{\OR}{\operatorname{\mathbf{OR}}}
\newcommand{\WHILE}{\operatorname{\mathbf{WHILE}}}
\newcommand{\DO}{\operatorname{\mathbf{DO}}}
\newcommand{\VARIANT}{\operatorname{\mathbf{VARIANT}}}

%% Commonly used math entities
\newcommand{\pow}{\operatorname{\mathbb{P}}}
\newcommand{\dom}{\operatorname{\mbox{dom}}}
\newcommand{\nat}{\operatorname{\mathbb{N}}}
\newcommand{\pfun}{\operatorname{\rightarrow\mkern-22mu+}}

\begin{document}
%---------------------------------------------------------- PAGINA DE CAPA %
% Número do relatório (para reserva, consulte "regivan@dimap.ufrn.br.br").
\TRNumber{000}

% O tipo do documento: Relatório Técnico, Relatório de Disciplina, etc.
%   \TRType{Technical Report}
%   \TRTipo{Relatório Técnico}

%\TRType{Final Year Project Proposal}
%\TRTipo{Prop. de Projeto F. de Curso}

% \TRType{Lecture Report}
% \TRTipo{Relatório de Disciplina}


% Data de publição (para a capa)
\TRYear{2009}  
\TRMonth{02} % Numérico, 01-12

% Lista de autores para capa (sem afiliações).
\TRAuthor{Stephenso Galvão, David Déharbe}

% Título para a capa (use \\ para forcar quebras de linha).
\TRTitle{Modelagem em B do \\Sistema de Tempo Real FreeRTOS}

\TRMakeCover
%---------------------------------------------------------- PAGINA DE CAPA %


%%---------------------------------------------------------- TITULO E AUTOR DA PAG 1 %
% TITULO e NOMES DOS AUTORES, completos, para a pagina 1.
% Use "\\" para quebrar linhas, "\and" para separar autores.
%
\title{\bf Modelagem em B do \\Sistema de Tempo Real FreeRTOS}

\author{Stephenson Galvão \\ {\small stepgalvao@consiste.ufrn.br}  
	 \and David Déharbe \\ {\small deharbe@consiste.ufrn.br} }
    %\thanks{Aluno do Programa de Pós-graduação em Sistemas e Computação,  UFRN}
\date{}

\maketitle
%---------------------------------------------------------- TITULO E AUTOR DA PAG 1 %


%---------------------------------------------------------- CABECALHO DAS PAGINAS %
% Nomes de autores ABREVIADOS e título ABREVIADO, para cabecalhos em cada página.
\markboth{\small Galvão, S.S.L.}{\small Modelagem do FreeRTOS}
\pagestyle{myheadings}
%---------------------------------------------------------- CABECALHO DAS PAGINAS %


%----------------------------------------------------------ABSTRACT %
\begin{abstract}
This is the abstract. 
\end{abstract}

\begin{keywords}
FreeRTOS.
\end{keywords}
%----------------------------------------------------------ABSTRACT %

%----------------------------------------------------------RESUMO %
\begin{resumo} 
Este é o resumo
\end{resumo}

\begin{palavras-chave}
FreeRTOS.
\end{palavras-chave}
%----------------------------------------------------------RESUMO %


\section{Introdução}
\label{sec:intr}


Sistemas de Tempo Real (STR) são sistemas que tem como principal característica
um rigoroso tempo de resposta aos eventos externos. Devido a isso, eles são bastante
utilizados, pelas industrias, em aplicações críticas que possuem o tempo de
respota como um fator crucial. O monitoramento de paciente em hospitais, o controle de
processos industriais e o controle de veículos (aeronaves, trens e automóveis)
são apenas alguns exemplos de aplicações dos sistemas de tempo real.

Em razão dessa  grante importância e utilização dos STR, foi proposto, por Jim,
em \cite{jim:sbmf}, como um dos grandes desafios da ciência da computação, a
especificação formal de um sistema operacional de tempo real, denominado
FreeRTOS. Para assim, proporcionar ao mesmo a segurança, confiabilidade e
coerência que uma especificação formal oferece, tornando-no mais fidedigno

O FreeRTOS é um sistema operacional de tempo real bastanten simple. Aprova disso
está em seu código fonte, que é aberto e composto aproximadamente 2.242 linhas de
código, número bastante pequeno para um sistema operacional. Além disso, ele é
capaz de trabalhar em ambientes com quantidade de recursos limitada, como os
microprocessadore, sendo, oficialmente\footnote{Existem também portas do FreeRTOS
não oficias, disponibilizada pelos usuários, para várias outras arquiteturas
diferentes}, portável para 17 arquiteturas de microprocessadores diferentes,
entre ela as \textit{PIC}, \textit{ARM}, \textit{Zilog 80} e \textit{Cygnal
8051}, arquiteturas bastante usada pelas industrias de microeletrónica
\cite{freertos}.

Seguindo esse contexto, o presente relatório tem como principal objetivo
descrever uma modelagem inicial em B, do STR FreeRTOS e, com isso, iniciar a
resolução do desafio proposto pelo Jim. Entretanto, por trata-se de uma
especificação inicial, alguns conceitos desse sistema de tempo real foram
brevemente abstraídos da modelagem, sendo que os mesmo serão tratados em futuros
refinamento. 
%Assim, primordialmente foram especificados, em um alto nível de
%abstração, somente os conceitos e funcionalidades de tarefas e filas de
%mensagens, dando ênfase principalemente à caracteristica de estado de um
%tarefa e suas trocas.

Para cumprir o seu objetivo, esse relatório foi divido da seguinte forma:
primeiramente tem-se uma introdução ao FreeRTOS, demonstrado as suas principais
características e conceitos fundamentais; em seguinda, é apresentado o plano de
modelagem seguido na realização da especificação, nele estão presente, junto com
suas descrições, as funcionalidades e os conceitos das API escolhidos para serem
desenvolvidos nessa modelagem inicial; após isso, na sessão \ref{sec:Modelling},
é demonstrado como foi feita a modelagem do FreeRTOS, suas máquinas com seus
estados e operações; e para encerrar, tem-se as considerações finais, onde
estão as conclusões do trabalho, e os trabalhos futuros, falando como será
feita a continuação desta modelagem.




%Para ser aceito para publicação, um Relatório Técnico deve ser avalisado por,
%pelo menos um professor do INF. No caso de um professor ser autor ou co-autor
%do relatório, poderá solicitar que um outro professor faça a avaliação do
%mesmo. Neste caso, o nome deste professor avaliador deverá constar na seção de
%agradecimentos (Seção \ref{sec:agrad}).



\section{FreeRTOS}
\label{sec:freertos}
% [Uma introdução ao FreeRTOS demonstrando as suas funcionalidades (casos no qual
% o FreeRTOS é utilizado), características(portabilidade, pouco código,ect) e
% conceitos(tarefa,co-rotina, fila de mensagem, mutex, ect)]
 
O \textit{FreeRTOS} é um sistemas de tempo real projetado para ser pequeno,
simples e fácil de usar. O seu código fonte é aberto e possui aproximadamente
2.242 linhas de código, que estão basicamente distribuidas em três arquivos
(task.c, queue.c e list.c), nos quais são implementados seus principais conceitos
e funcionalidades. Além disso, outra característica importante desse STR é a sua
portabilidade, sendo oficialmente portável para 17 arquiteturas diferentes, entre
elas a PIC, ARM, Zilog Z80 e PC, bastantes usadas pelas industrias de
microeletrônica.

O seu \textit{kernel}, além de ser multiprocesso, suporta três tipo diferentes de
configurações: preemptivo, cooperativo e híbrido. No tipo preemptivo, a processo
em execução pode ser enterrompido a qualquer momento pelo escalonador, sendo em
seguida substituido por outro processo. Diferentimente, no tipo cooperativo, o
processo em execução é quem descide o momento de sua pausa, seguida da sua
substituição. E por fim, no tipo híbrido, o escalonador funciona hora como
preemptivo e hora como cooperativo.

Os conceitos fundamentais implementado pelo FreeRTOS e presente na maioria dos
sistemas de tempo real são tarefa, co-rotina, fila de mensagem, semáforo e mutex.
Eles junto com suas funcionalidades formam todo o núcleo do FreeRTOS, restanto
para o usuário apenas a utilização dos mesmo para a criação de novos sistemas. A
seguir, detalharemos as características e utilização de cada um desses conceitos.

\subsection{Tarefa}
\label{subsec:tarefa}
Tarefas são unidades de trabalho independentes que compoem um sistema
multitarefas. No FreeRTOS, uma tarefa é composta por: um pilha de contexto, que
serve para armazenar o contexto de execução (estados dos registradores)  no
momento que uma tarefa é interrompida; uma prioridade que serve para indicar a
sua importância da tarefa para o sistema; um estado que desmonstra a atual
situação da tarefa; e uma função que é executado quando a tarefa assume o
controle do processado \cite{Li:2003}.

Os estados que uma tarefa pode assumir no FreeRTOS são: executando, pronto,
bloqueado e suspenso. O estado ``executando'' informa que a tarefa está em
execução, ou sejá, possui, atualmente, o controle do processador. Somente uma
tarefa pode possuir o estado executando no FreeRTOS. O estado ``pronto'' informa
que a tarefa está pronta para entrar em execução, aguardando apenas assumir o
controle do processador. No estado ``bloqueado'' a tarefa encontra-se bloqueada a
espera de algum evento necessário para continuar a sua execução. E por último, no
estado ``suspenso'', a tarefa foi suspensa pelo escalonador através da chamada ao
método vTaskSuspend(), disponível na API do FreeRTOS. O gráfico completo de
transição de estados que uma tarefa pode sofre é demonstrado na figura
\ref{fig:tkstates}.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{tkstate.eps}
\caption{Gráfico de transição de estados das tarefas do FreeRTOS}
\label{fig:tkstates}
\end{figure}

A prioridade de uma tarefa pode váriar de 0 até uma constante de prioridade
máxima, definida pelo o usuário. No FreeRTOS, as prioridades servem para indicar
a importância de uma tarefa para o sistema. Elas são usadas principalmente pela
política de escalonamento entre tarefas. Nessa política, as tarefas de maior
prioridade, tem preferência sobre as tarefas de menor prioridade do mesmo estado.
Assim, para escolher a tarefa que irá entrar em execução, o escalonador percorre
a lista de tarefas com o estado ``pronto'' selecionando aquela de maior
prioridade. Um exemplo do  funcionamento do escalonador pode ser visto na na
figura \ref{fig:scheduler}, na qual as tarefas de menores prioridades são
interrompidas por tarefas de maiores prioridades quando estas assumem o estado
``pronto''. Outro fator importante no funcionamento de escalonador que vale
apena resalta, é que tarefas de mesma prioridade dividem o tempo de execução
entre si. Com isso, se houver duas tarefas prontas e com a prioridade máxima,
elas irão dividir o tempo de processamento em frações iguais.


\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{scheduler.eps}
\caption{Funcionamento do escalonador do FreeRTOS}
\label{fig:scheduler}
\end{figure}

%Assim, o gráfico de transição de estados das tarefas do FreeRTOS comporta-se
%como o da figura \ref{fig:tkstates}.Nele uma tarefa pode ir do estado
%executando para pronta, bloqueado ou suspensa, de bloqueada para suspensa ou
%pronta, de suspensa para pronta e de pronta para executando ou suspens

% [Exemplificar utilizando uma figura do funcionamento do escalonador do
% FreeRTOS]
  
\subsection{Co-Rotina}
\label{subsec:crotina}
As co-rotinas são similares às tarefas, também possuem prioridade, estados e uma
função que é executado no momento em que a co-rotina assume o controle do
escalonador. Entranto, existem algumas diferenças importantes entre tarefas e
co-rotinas, sendo a principal, a ausência da pilha de contexto. Co-rotinas não
possuem pilha de contexto e, conseguentemente, não possuem contexto próprio, ou
seja, os valores armazenados nos registradores por uma co-rotinas, não são
guardados no momento em que ela interrompe a sua execução. Assim, uma co-rotina
pode armazenar o valor três em um registrador, antes de interrompe-se, e, quando
ela retorna a sua execução, o valor dessa variável pode ou não ser o mesmo, pois
pode ter entrado em execução e alterado o valor do registrado.

Outra diferença importante entre co-rotinas e tarefas está na quantidade de
estado. As co-rotinas só possuem os estado ``executando'', ``pronto'' e
``bloqueada'' diferente que, além dos três, possuem o estado ``suspenso''.
Conseguentemente, o gráfico de transição de estados de uma co-rotina também é
diferente do gráfico de tarefas, sendo esse demonstrado pela figura
\ref{fig:cstates}

As co-rotinas também possuem um gerenciamento diferente do de tarefas. Elas são
escalonadas de forma coopertiva, ou seja, elas são quem descidem o momento da sua
interrupção. Assim, resta apenas ao escalonador a tarefa de descidir qual
co-rotina deve assumir o processador no momento em que a co-rotina em execução
interrompe-se, sendo que a política usada para essa escolha é a mesma usadas
pelas tarefas.


\subsection{Fila de Mensagens}
\label{subsec:fmensagem}
Filas de mensagens são estruturas primitivas de comunicação entre tarefas. Elas
funcionam como um túnel no qual tarefas enviam e recebem mensagem. No FreeRTOS,
as filas de mensagens possuem tamanho fixo defino pelo tamanho e quantidade de
ítens (mensagem) que ela pode armazenados. Para uma tarefa enviar uma mensagem
para uma fila, primeiramente a fila não pode estar cheia, caso contrário, a
tarefa é bloqueada até que seja liberado um lugar na fila. O mesmo 
ocorre quando uma tarefa tenta receber uma mensagem de uma fila, só que,
nesse caso, a fila deve possuir pelo menos um item, para que esse seja lido,
caso contrário, a tarefa é bloqueda até a chegada de um item na fila de
mensagens.

No FreeRTOS, é possível definir o tempo máximo que uma tarefa pode ficar
bloqueada esperado por um evento(liberação de espaço ou chega de mensagem) em
uma fila. E no casos em que existerem mais de uma tarefa bloqueadas aguardando
por um evento de uma fila, as tarefas de maior prioridade têm preferência sobre
as demais.

\subsection{Semâforos}
Semâforos são mecanismo usados na sicronização entre tarefas. Eles funcionam como
uma chave que libera, ou não, o uso de um determinado recurso. Assim quando uma
tarefa deseja acessar um recurso comportilhado, ela primeiramente deve solicitar
o semâforo do recurso, caso esteja liberado, a tarefa tem a permição de utilizar
o recurso e, em seguida, libera o semáforo, caso contrário, a tarefa é
bloqueada até que o semáforo sejá liberado.

No FreeRTOS os semâforo funcionam como uma fila de mensagens com um único item.
Assim, quando a fila estiver vazia, indica que o semáforo está sendo usado e,
quando a fila estiver cheia, indica que o semâforo está liberado. Desse modo, as
tarefas que utilizam essa fila não estão preocupadas com o conteúdo
do item, mas apenas com o estado da fila, se ela está cheia ou vazia.


\subsection{Mutex}
Mutex são parecidos com o semáforo. A única diferênça entre os dois é que o mutex
implementa o mecanismo de herança de prioridade, o qual impede que uma tarefa de
maior prioridade fique bloqueada a espera de um semáforo ocupado por uma tarefa
de menor prioridade, causando o que chamamos de inversão de prioridade.

Para evitar esse problema, o mecanismo de herança de prioridade, ao perceber
que uma tarefa solicita o semáforo, verifica se a tarefa solicitante possui
prioridade maior que a tarefa com o semáforo. Caso afirmativo, a tarefa que
retém o semâforo tem mometaneamente sua prioridade elevada, para que assim ela
possar realizar a suas funções sem interrupções e, conseguentemente, liberar
rapidamente o semáforo.

\section{Projeto da Modelagem}
\label{sec:project}

Como demonstrado na sessão anterior, o FreeRTOS possui uma grande quantidade de
conceitos fundamentais. Devido a isso, antes de iniciar-se a sua especificação
foi criado em \cite{sroute} um projeto de modelagem, no qual alguns dos
seus principais conceitos fundamentais, junto com suas funcionalidades foram
escolhidos para serem modelados inicialmente. Assim, o projeto de modelagem
funcionou como um roteiro para a especificação, dizendo como o por onde começar a
modelagem do FreeRTOS.

Devido a sua grande importância, os conceito fundamentais escolhidos no projeto
de modelagem foram, tarefa (sessão \ref{subsec:tarefa}) e fila de mensagem
(sessão \ref{subsec:fmensagem}), sendo que cada um desses conceito possui uma
enorme quantidade de funcionalidades. Assim, para o melhor entendimento e
gerenciamento, essas funcionalidades foram classificadas em cinco conjuntos
diferentes: criação de tarefa; controle de tarefa; controle do kernel;
utilidades de tarefas e gerenciamento de fila. A seguir, tem-se em detalhe
a composição de cada um desses conjuntos grupo como também a descrição de cada
funcionalidade que os compoem

\subsection{Criação de tarefa}
\label{subsec:tcreation}

No conjuto Criação de tarefas, estão presente algumas funcionalidades
responsáveis pela criação, exclusão e referênciamente de uma tarefa. Ele é
formado pelas seguintes operações:

\begin{itemize}
  \item \textbf{xTaskCreate} - Cria uma nova tarefa que será gerenciada pelo
  FreeRTOS, retornando uma referência para a tarefa criada. Caso a tarefa não
  possa ser criada, uma referência nula é retornada no lugar da tarefa criada
  
  \item \textbf{xTaskDelete} - Remove uma tarefa do FreeRTOS. Entranto, os
  espaço alocado pela tarefa só será liberando pela a tarefa ociosa
  \footnote{Tarefa executada quando o processador estar ocioso (sem tarefas
  para entrar em execução). Ela é responsável pela liberação da memória
  alocada por determinadas estruturas (Tarefa, Fila de Mensagem, Co-rotina, etc)
  no FreeRTOS}.
  
  \item \textbf{xTaskHadle} - Estrutura de referênciamento a uma tarefa
\end{itemize}

\subsection{Controle de tarefa}
\label{subsec:tcontrol}
O grupo de Controle de tarefa é responsável pelo controle e gerênciamento das
tarefas presentes no FreeRTOS. Desse modo, as funcionalidades que forma esse
grupo são:

\begin{itemize}
  \item \textbf{uxTaskPriorityGet} - Informa a prioridade de uma tarefa
  
  \item \textbf{vTaskSuspend} - Coloca uma tarefa no estado ``suspenso''
  
  \item \textbf{vTaskResume}- Retorna uma tarefa suspensa colocando-a no estado
  pronto
  
  \item \textbf{vTaskPrioritySet} - Altera a prioridade de uma tarefa
  
  % \NOTE - Pedir para o David ler essa parte
  \item \textbf{vTaskDelay} - Bloqueia uma tarefa por uma determinada
  quantidade de tempo. Nesse método, o tempo de desbloqueio de uma tarefa é
  calculado com base no tempo de chamada ao mesmo, o que torna-no não
  recomendável para a criação de tarefas cíclicas, pois outras tarefas e
  interrupções podem influenciar no tempo em que o método será chamado
  novamente.
  
  \item \textbf{vTaskDelayUntil} - Esse método, assim como o
  \textit{vTaskDelay}, coloca uma tarefa no estado bloqueado por uma determinada
  quantidade de tempo. Entretanto, diferentemente do método passado, o tempo de
  desbloqueio de uma tarefa é calculado com base no instante do último
  desbloqueio mesma. Assim é garantido que tempo entre o bloqueio e o
  desbloqueio de uma tarefa será sempre o mesmo, o que torna esse método
  recomendado para a criação de tarefas cíclicas.
  
\end{itemize}

\subsection{Controle do kernel}
\label{subsec:kcontrol}
As funcionalidades presentes no conjunto Controle do kernel são responsáveis por
gerênciar, iniciar e finalizar as atividades. Nesse grupo estão presentes as
seguintes operações:

\begin{itemize}
  \item \textbf{vTaskStartScheduler} - Esse método primeiramente cria a tarefa
  ociosa e em seguinda inicia as atividades do escalonador, colocando-o no
  estado ``executando''\footnote{O escalonador do FreeRTOS possui três estados:
  executando, que indica que o escalonador está em execução; não iniciado, que 
 indica que o escalonador não foi inicializado ainda; e suspenso, que indica qu
e a atividades do escalonador estão suspensas }. Caso, a tarefa ociosa não
possa ser criada, o escalonador não será inicializado permanecendo no estado
não iniciado.

  \item \textbf{vTaskEndScheduler} - Finaliza as atividades do escalonador
  colocando-o no estado não iniciado. Para isso ele primeiramente exclui todas as
  estruturas (tarefas, filas de mensagens, co-rotinas, etc) criadas no FreeR
 TOS e em seguida finaliza o escalonador.
 
  \item \textbf{vTaskSuspendAll}- Suspende temporariamente todas atividades do
  escalonador colocando-o no estado suspenso.
  
  \item \textbf{xTaskResumeAll}- Retorna todas as atividades do escalonador
  quando esse encontra-se no estado suspenso.
  
\end{itemize}


\subsection{Utilidades de tarefas}
\label{subsec:tutilities}
No grupo de utilidades de tarefas, encontram-se as operações responsáveis
por fornecer informações úties sobre o estado do kernel. Esse grupo é composto
pelas seguintes funções:

\begin{itemize}
  \item \textbf{xTaskGetCurrentTaskHandle} - Retorna a referência para a
  tarefa em execução
  \item \textbf{xTaskGetSchedulerState} - Informa o atual estado do
  escalonador (executando, suspenso ou não iniciado).
  \item \textbf{uxTaskGetNumberOfTasks} - Informa a atual quantidade de tarefas
  tarefas do FreeRTOS.
  \item \textbf{xTaskGetTickCount} - Informa a quantidade de tempo decorrido
  desde a inicialização do escalonador 
\end{itemize}

\subsection{Gerenciamento das filas de mensagens}
\label{subsec:fmanagemente}
As funcionalidades presentes no grupo Gerenciamento das filas de mensagens cabêm
as obrigações de gerenciar, criar eexcluir as filas de mensagens do FreeRTOS.
Esse grupo é formado pela as seguintes funções:

\begin{itemize}
  \item \textbf{xQueueCreate} - Cria uma nova fila de mensagem, retornando uma
  referência para a mesma. Caso a fila de mensagem não possa ser criada, uma
  referência de fila nula é retornada.
  
  \item \textbf{xQueueSend} - Método usado por uma tarefa para enviar uma
  mensagem para uma fila de mensagens. Caso a fila esteja cheia e não possa
  receber a mensagem, a tarefa é bloqueada até que seja liberado uma lugar na
  fila.
  
  \item \textbf{xQueueSendToBack} - Esse método funciona do mesmo modo que o
  \textit{xQueueSendToBack}. Ele envia uma mensagem para o final de uma fila de
  uma fila de mensagem e caso essa esteja cheia, a tarefa que utilizou o método
  é bloqueada até que seja liberando um lugar na fila.
  
  \item \textbf{xQueueSendToFront} - Método utilizado por uma tarefa para
  enviar uma mensagem para o início de uma fila de mensagem. Caso a fila esteja
  cheia, a tarefa é bloqueada até que seja liberado um espaço na fila de
  mensagem
  
  \item \textbf{xQueueReceive} - Método utilizado por uma tarefa para ler e
  retirar uma mensagem localizada no início da fila de mensagens. Caso a fila de
  mensagens esteja vazia, a tarefa é bloqueada até que uma mensagem chegue na
  fila.
  
  \item \textbf{xQueuePeek} -  Método utilizado por uma tarefa para ler sem
  retirar uma mensagem localizada no início da fila de mensagens. Caso a fila de
  mensagens esteja vazia, a tarefa é bloqueada até que uma mensagem chegue na
  fila.
  
  \item \textbf{vQueueDelete} - Exclui uma fila de mensagens do FreeRTOS.
  Entretando, o espaço oculpado pela a mesma só será liberado pela a tarefa
  ociosa.
  
\end{itemize}

\subsection{Parâmentros de configuração}
\label{subsec:config}
Os parâmetros de configuração são atributos usados na implementação das
funcionalidades descritas acima. Eles são responsáveis pelo o comportamento e
configuração do sistema. Assim antes da criação de novos sistemas utilizando o
FreeRTOS o usuário primeiramente de preencher-los de acordo com as necessidades
do sistema. A lista completa de todos os parâmentros utilizados no projeto
\textit{sheet route} pode ser encontrada a seguir:

\begin{itemize}
  \item {\textbf{configMAX\_PRIORITIES} - Esse parâmentro informa o número da
  prioridade máxima que pode ser utilizada no FreeRTOS}
  \item {\textbf{INCLUDE\_vTaskPrioritySet} - Indica a utilização ou não da
  funcionalidade \textit{vTaskPrioritySet}}
  \item {\textbf{INCLUDE\_vTaskSuspend} - Indica a utilização ou não da
  funcionalidade \textit{vTaskSuspend}}
  \item {\textbf{INCLUDE\_uxTaskPriorityGet} - Indica a utilização ou não da
  funcionalidade \textit{uxTaskPriorityGet}}
  \item {\textbf{INCLUDE\_vTaskDelete} - Indica a utilização ou não da
  funcionalidade \textit{vTaskDelete}}
  \item {\textbf{INCLUDE\_xTaskGetSchedulerState} - Indica a utilização ou não
  da funcionalidade \textit{xTaskGetSchedulerState}}
  \item {\textbf{INCLUDE\_xTaskGetCurrentTaskHandle} - Indica a utilização ou
  não da funcionalidade \textit{xTaskGetCurrentTaskHandle}}
  \item {\textbf{INCLUDE\_vTaskDelay} - Indica a utilização ou
  não da funcionalidade \textit{vTaskDelay}}
  \item {\textbf{INCLUDE\_vTaskDelayUntil} - Indica a utilização ou
  não da funcionalidade \textit{vTaskDelayUntil}} 
\end{itemize}
	
\section{Modelagem}
\label{sec:Modelling}

A modelagem B do FreeRTOS, foi dividida entre 7 máquinas (), nas quais são
modelados os conceitos de tarefa, fila de mensagem, suas funcionalidades e seus
parâmetros de configuração, descritos na sessão \ref{sec:project}. Assim, para
uma melhor compreensão essa sessão foi dividida da seguinte forma, modelagem
dos conceitos, explica como foram modelados os conceitos de tarefa e fila de
mensagem, e modelagem das funcionalidades, demonstra como foram especificadas
as funcionalidades e os parâmetros de configuração do FreeRTOS.

\subsection{Modelagem dos conceitos}
\subsubsection{Tarefas}

%Como dito na sessão \ref{subsec:tarefa}, o conceito de tarefa é formado pelas
%seguintes características: pilha de contexto, estado, prioridade e função de
%execução. 

O conceito de tarefa é modelado através da máquina $\mathbf{Task\_Core}$.
Entretanto, devido às dificuldades encontradas no momento das obrigações de
prova, esse conceito foi modelado inicialmente contendo apenas a característica
de estado, sendo as demais características (ver sessão \ref{subsec:tarefa})
especificadas em futuros refinamento. Assim, a especificação do conceito de
tarefa foi feita como demonstra as figura \ref{fig:task-modelling}, na qual
inicialmente foi criado o conjuto abstrato $\mathit{TASK}$, que simboliza o
conjunto universo de todas as tarefas que podem ser criadas pelo FreeRTOS e, em
seguida, o  estado $\mathit{tasks}$, que representar as tarefas gerenciadas pelo
FreeRTOS, gerando a seguinte definição $\mathit{tasks} \in
\mathbf{FIN}(\mathit{TASK})$.

Ainda na figura \ref{fig:task-modelling}, a especificação dos estados de uma
tarefa é feita através das variáveis $\mathit{blocked}$, $\mathit{running}$,
$\mathit{ready}$ e $\mathit{suspended}$, as quais representam os estados,
bloqueado, executando, pronto e suspenso, respectivamente. Com isso, uma tarefa
que encontra-se no estado bloqueado, deve obrigatoriamente pertencer ao conjunto
de tarefas bloqueadas, $\mathit{blocked}$. Já  as restrições relacionadas a esses
estados, demosntradas na figura \ref{fig:task-modelling}, determinam que somente
uma tarefa pode estar em execução e que uma tarefa não pode possuir mais de uma
estado em um mesmo momento.

\begin{figure}[!b]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{SETS}\\
\quad   \mathit{TASK};\\
\quad   \ldots \\\\
    		
\mathbf{VARIABLES}\\
\quad   \mathit{tasks},\\
\quad   \mathit{blocked},\\
\quad	\mathit{running},\\
\quad	\mathit{ready}, \\
\quad	\mathit{suspended}\\
\quad	\ldots
\end{array}
\begin{array}[t]{l}

\mathbf{INVARIANTS}\\

\quad \mathit{tasks} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{tasks} \neq \emptyset \land \\\\

\quad \mathit{blocked}	\in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{blocked} \subset \mathit{tasks} \land \\\\

\quad \mathit{ready} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{ready} \subset \mathit{tasks} \land \\\\	

\quad \mathit{suspended} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{suspended} \subset \mathit{tasks} \land \\
\quad \ldots
\end{array}

\begin{array}[t]{l}
\quad \mathit{running} \in \mathit{TASK} \land \\
\quad \mathit{running} \in \mathit{tasks} \land \\
\quad \mathit{running}  \not\in \mathit{ready} \land \\
\quad \mathit{running} \not\in  \mathit{blocked} \land \\
\quad \mathit{running} \not\in  \mathit{suspended} \land \\\\

\quad \mathit{ready} \cup \mathit{blocked} = \emptyset \land \\ 
\quad \mathit{blocked} \cup \mathit{suspended} = \emptyset \land \\
\quad \mathit{suspended} \cup \mathit{ready} = \emptyset \land \\\\

\quad \mathit{tasks} = \mathit{\{running\}} \cup \mathit{suspended} \\ 
\quad\quad\quad\quad\quad \cup \mathit{blocked} \cup \mathit{ready}

\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem do conceito tarefa}
\label{fig:task-modelling}
\end{figure}

\subsubsection{Fila de Mensagem}
A maquina responsável pelo conceito de fila de mensagens e a
$\mathbf{QUEUE\_CORE}$. Nela, uma fila de mensagem mensagem é especificada como
sendo um conjunto de item, um conjunto de tarefas aguardando por um espaço na
fila e um conjunto de tarefas a espera de um item da fila, como demonstra a
figura \ref{fig:queue-modelling}. As demais características de um fila de
mensagem (ver sessão \ref{subsec:fmensagem}) serão modeladas em futuros
refinamento. 

Assim, na especificação da figura \ref{fig:queue-modelling}, os conjuntos
abstratos $\mathit{QUEUE}$ e $\mathit{ITEM}$, simbolizam todas as filas e itens
que podem ser criados pelo FreeRTOS. E a variáveis $\mathit{queues}$,
$\mathit{queue\_items}$, $\mathit{queue\_receiving}$ e $
\mathit{queue\_sending}$, representam, respectivamente, as fila gerenciadas pelo
FreeRTOS, uma função que liga uma fila a um conjunto de itens, uma função que
liga uma fila a um conjunto de tarefas que esperam pela chegada de um item na
fila e uma função que liga uma fila a um conjunto de tarefas que esperam por um
espaço na fila. 

Com isso, para criar-se uma fila, primeiramente adiciona-se uma representação da
mesmo no conjunto $\mathit{queues}$ e , em seguinda, a mesma representação deve
ser associada a um conjunto de itens e tarefas através das demais variáveis, pois
como determina as definições $\mathit{queues} =
\mathbf{dom}(\mathit{queue\_items})$, $\mathit{queues} =
\mathbf{dom}(\mathit{queue\_receiving}) $ e $\mathit{queues} =
\mathbf{dom}(\mathit{queue\_sending})$, toda fila gerenciada pelo FreeRTOS deve
possuir um conjunto de itens, e dois conjuntos de tarefas que esperam por um
lugar ou item na fila.

\begin{figure}[!b]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{SETS} \\
\quad   \mathit{QUEUE};\\
\quad   \mathit{ITEM};\\
\quad   \ldots \\
    		
\mathbf{VARIABLES}\\
\quad   \mathit{queues},\\
\quad\quad   \mathit{queue\_items},\\
\quad\quad   \mathit{queue\_receiving},\\
\quad\quad	 \mathit{queue\_sending}
\end{array}

\begin{array}[t]{l}

\mathbf{INVARIANTS}\\

\quad \mathit{queues} \in \mathbf{POW}(\mathit{QUEUE}) \land \\
\quad\quad \mathit{queue\_items} \in \mathit{QUEUE} \rightarrow\mkern-22mu+
\quad\quad \mathbf{POW}(\mathit{ITEM})\land \\

\quad\quad \mathit{queue\_receiving} \in \mathit{QUEUE} \rightarrow\mkern-22mu+
\quad\quad \mathbf{POW}(\mathit{TASK}) \land \\ 

\quad\quad \mathit{queue\_sending} \in \mathit{QUEUE}\rightarrow\mkern-22mu+
\quad\quad \mathbf{POW}(\mathit{TASK}) \land \\\\
    		
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_items}) \land \\
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_receiving}) \land \\
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_sending})

\end{array}

\end{array}
$$
\end{small}
\caption{Modelagem do conceito fila de mensagem}
\label{fig:queue-modelling}
\end{figure}

\subsection{Modelagem das funcionalidades}
\label{subsec:fun-modelling}
A modelagem das funcionalidades e um pouco mais complexa que a modelagem dos
conceitos.Por isso, primeiramente dividiremos as funcionalidades em dois grupos, 
funcionalidades de tarefa, nas quais estão as funcionalidades relacionadas ao
conceito de tarefa e funcinalidades das fila de mensagem, onde estão as
funcionalidades relacionadas às filas de mensagens.

\subsubsection{Funcinalidades de tarefa}
\label{subsubsec:tutilities}
Esse grupo grupo é composto pelo o conjunto de  funcionalidades de criação de
tarefa ( sessão \ref{subsec:tcreation}), controle de tarefa (sessão
\ref{subsec:tcontrol}), utilidades de tarefa (sessão \ref{subsec:tutilities}) e
controle do kernel (sessão \ref{subsec:kcontrol} ), sendo essas especificadas
através das máquinas $\mathbf{TASK\_CORE}$ e $\mathbf{TASK\_BASIC}$. Na máquina
$\mathbf{TASK\_CORE}$ além do conceito de tarefa, foram modeladas também
operações básica que servem como suporte para a especificação das
funcionalidades de tarefa. Nela estão presente as seguintes funções:
\begin{itemize}
\item{\textbf{Create} - Cria uma nova tarefa gerenciada pelo FreeRTOS, podendo
as mesma possuir estado executando ou pronta, dependendo da prioridade da mesma.
Entranto, como a característica prioridade foi abstraida dessa modelagem inicial,
cabe ao refinamento que implementar tal característica descidir quando uma tarefa
será criada com os estado pronto ou executando. Por isso esta, foi implementada
recebendo uma prioridade como parâmetro, sendo que o mesmo não é usado
inicialmente}

\item{\textbf{Delete} - Exclui uma tarefa gerenciada pelo FreeRTOS. Se a tarefa
que será excluida é a tarefa em execução, uma nova tarefa será escolhida, entre
as tarefas de estado pronto, para entrar em execução.}

\item{\textbf{Suspend} - Coloca uma tarefa no estado suspenso.No caso em que a
tarefa suspensa será a tarefa em execução, uma nova tarefa deverá ser escolhida,
entre as tarefas com estado pronto, para entrar em execução.}

\item{\textbf{Resume} - Retorna uma tarefa que estava no estado suspenso
colocando-a no estado pronto ou executando.}

\item{\textbf{GetPriority} - Retorna a prioridade de uma determinada tarefa, mas como a característica
prioridade não é especificada nessa modelagem inicial, essa operação retorna
apenas um elemento que pertence ao conjunto abstrado denominado
$\mathit{PRIORITIES}$, o quais representa as possíveis prioridades do FreeRTOS.}

\item{\textbf{GetCurrent} - Retorna uma referência para a atual tarefa em
execução}

\item{\textbf{GetNumberOfTasks} - Retorna o número de tarefas que estão sendo gerenciadas pelo FreeRTOS, ou seja,
retorna a cardinalidade do conjunto $\mathit{tasks}$ (sessão
\ref{fig:task-modelling}).}

\item{\textbf{DelayTask} - Coloca a tarefa em execução no estado boqueado por
uma determinada quantidade de tempo.}

\item{\textbf{Unblock}- Desboqueia uma tarefa que estava bloqueada, colocando-a
no estado pronto ou executando.}
 
\item{\textbf{StartScheduler}- Cria a \textit{idle task} (sessão
\ref{subsec:kcontrol}), podendo ela ser cirada com o estado executando ou com o estado pronto}

\item{\textbf{EndScheduler} - Exclui todas as tarefas do FreeRTOS, zerando os
conjunto de estado e colocando a referência de tarefa nula na variável da
tarefa em execução.}

\item{\textbf{ResumeAll} - Desbloqueia todas as tarefas que deveriam ser
boqueadas enquanto o escalonador estava suspenso devido à chamada ao método $\mathit{vTaskSuspendAll}$ (sessão
\ref{subsec:kcontrol}).}

\end{itemize}

Na máquina $\mathbf{TASK\_BASIC}$ é onde as funcionalidades são realmente
especificadas. Para isso, além de utilizar do conceito de tarefa e
funcionalidades básica da $\mathbf{TASK\_CORE}$, ela também especifica algumas
características importantes para modelagem dessas funcionalidades, sendo elas
tick \footnote{Unidade de tempo usada pelo FreeRTOS. Nele o tempo é medido
através de pulso de clock decorridos. Assim para cada pulso de clock o tick do
FreeRTOS é incrementado de uma unidade }, especificada através das variáveis
$\mathit{tickCount}$ e $\mathit{tickMissed}$ que armazenam respectivamente a
quantidade de ticks decorrido quando o escalonador estar em execução e quando ele
estar suspenso, e estado do escalonador (sessão \ref{subsec:kcontrol}), definido
através do conjunto $\mathit{SCHEDULER\_STATE}$ e pela variável
$\mathit{scheduler}$, que representam os possíveis estados de um escalonador e o
seu atual estado, respectivamente.

Como visto inicialmente, existem várias funcionalidades que compoem o grupo
funcionalidades de tarefa. Devido a isso nos iremos demonstrar apenas as
principais operações de cada conjunto, ficando ao critério do leitor,
verificar na especificação disponível em \cite{freertosb} a implementação das
demais funcionalidades.

\subsubsection*{Criação de tarefa} 
A principal operação do conjunto de
funcionalidades criação de tarefa é a $\mathit{xTaskCreate}$ (sesssão
\ref{subsec:tcreation}), a qual tem sua especificação demonstrada na figura. Nela
são declarados vários parâmetros de função que serão utilizados apenas em futuros
refinamentos. O seu funcionamento resulme-se na criação ou não de uma tarefa.
Assim, para realizar a criação de uma tarefa ela utiliza-se da função básica
$\mathit{Create}$ ( comentada acima) e em seguida retorna a constante
$\mathbf{pdPASS}$ informando que a tarefa foi criada com sucesso. E para caso da
tarefa não ser criada, ela retorna as constantes $\mathbf{TASK\_NULL}$ e
$\mathbf{errCOULD\_NOT\_ALLOCATE\_REQUIRED\_MEMORY}$, que representam
respectivamente uma tarefa nula e o erro de não possuir memória suficiente para a
criação da tarefa.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{result}, \mathit{handle} \longleftarrow \mathit{xTaskCreate}
										(\mathit{pvTaskCode},\mathit{pcName},\\
\quad\quad \quad\quad \quad\quad \quad\quad\quad\quad\quad\quad\quad\quad
			\mathit{usStackDepth},\mathit{pvParameters}, \mathit{uxPriority}) = \\
\mathbf{PRE}\\ 
\quad \mathit{pvTaskCode} \in \mathit{TASK\_CODE} \land \\ 
\quad \mathit{pcName} \in \mathit{NAME} \land \\ 
\quad \mathit{usStackDepth} \in \mathit{NATURAL} \land \\  
\quad \mathit{pvParameters} \subset \mathit{PARAMETER} \land \\ 
\quad \mathit{uxPriority} \in \mathit{PRIORITY} \land \\
\mathbf{THEN} \\
\quad \mathbf{CHOICE}\\ 
\quad \quad \mathit{handle} \leftarrow \mathit{Create} (\mathit{uxPriority})
				\parallel\\ 
\quad \quad \mathit{result} := \mathbf{pdPASS}\\
\quad	\mathbf{OR} \\
\quad \quad
\mathit{result}:=\mathbf{errCOULD\_NOT\_ALLOCATE\_REQUIRED\_MEMORY} \parallel \\ 
\quad \quad 
\mathit{handle} := \mathbf{TASK\_NULL} \\
\quad \mathbf{END};\\
\end{array}
\end{array}
$$

\end{small}
\caption{Modelagem da operação $\mathit{xTaskCreate}$}
\label{fig:xTaskCreate}
\end{figure}

\subsubsection*{Controle de tarefa} 

No grupo controle de tarefa, a operação escolhida foi $\mathit{vTaskDelay}$,
demonstrada na figura \ref{fig:vTaskDelay}. Para especificar o seu comportamento
foi necessário a primeiramente criar-se a função $\mathit{TICK\_INCREMENT}$,
usada para fazer uma soma entre dois tipos $\mathit{TICK}$. Assim para que a
operação coloque a tarefa em execução no estado bloqueado durante uma determinada
quantidade de tempo ela primeiramente soma a variável $\mathit{tickCount}$ com o
quantidade de tempo desejado e, em seguida, utiliza-se da operção básica
\textit{Delay}, que coloca uma tarefa no estado bloqueado até o \textit{tick}
informado. Outro fator importante na especificação dessa funcionalidade é que
como pré-condição aparece a restrição $\mathit{INCLUDE\_vTaskDelay} = 1$, a qual
informa que o parâmetro de configuração $\mathit{INCLUDE\_vTaskDelay}$ deve estar
preenchido com o valor um para que a operação seja realizada.


\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{vTaskDelay}(\mathit{xTicksToDelay})=\\
	\mathbf{PRE}\\
\quad    	\mathit{xTicksToDelay} \in \mathit{TICK} \land \\ 
\quad    	\mathit{INCLUDE\_vTaskDelay} = 1 \land \\
\quad    	\mathbf{not}(\mathit{TICK\_INCREMENT}(\mathit{tickCount},
			\mathit{xTicksToDelay})=0)\\ 
\mathbf{THEN}\\
\quad    \mathit{DelayTask} (\mathit{TICK\_INCREMENT} (\mathit{tickCount},
													\mathit{xTicksToDelay}))\\ 
\mathbf{END};
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{vTaskDelay}$}
\label{fig:vTaskDelay}
\end{figure}

\subsubsection*{Utilidades de tarefa} Na parte de utilidade de tarefa, as
operações são bastante simples, pois elas apenas retornam informações importantes
para o usuário sem fazer a alteração de qualquer estado da máquina. A operação
escolhida para esse grupo foi $\mathit{xTaskGetCurrentTaskHandle}$, cuja sua
especificação completa é exibida na figura \ref{fig:xTaskGetCurrentTaskHandle}.
Nela a pré-condição $\mathit{INCLUDE\_xTaskGetCurrentTaskHandle} = 1$ exige que
para que a sua utilização, o parâmetro de configuração
$\mathit{INCLUDE\_xTaskGetCurrentTaskHandle}$ deve estar preenchido com o valor
um e o seu funcionamento trata-se apenas da chamada à operação básica
$\mathit{GetCurrent}$.


\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{cTask} \longleftarrow \mathit{xTaskGetCurrentTaskHandle}= \\
	\mathbf{PRE}\\
\quad    	\mathit{INCLUDE\_xTaskGetCurrentTaskHandle} = 1\\
	\mathbf{THEN}\\
\quad    	\mathit{cTask} \gets \mathit{GetCurrent}\\

 
\mathbf{END};
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{xTaskGetCurrentTaskHandle}$}
\label{fig:xTaskGetCurrentTaskHandle}
\end{figure}


\subsubsection*{Controle do kernel} Na parte de controle do kernel, existem
várias operações importantes, entre elas está a $\mathit{vTaskStartSchedule}$ que
é especificada como demonstra a figura \ref{fig:vTaskStartSchedule}. Ela inicia
ou não as atividades do escalonador. Para iniciar as atividades do escalonador,
primieramente deve-se criar a \textit{idle task}, o que é feito pela função
$\mathit{StartScheduler}$, e em seguida deve-se colocar o estado do escalonador
para iniciado, o que é feito na declaração
$\mathit{scheduler}:=\mathbf{taskSCHEDULER\_RUNNING}$. Entretanto, antes de
utilizar-se essa funcionalidade deve garantir que o escalonador está no estado
não está em execução e que os conjuntos referentes as listas de tarefas estão
vazios ou possuem somente a tarefa nula, no caso de $\mathit{tasks}$ e
$\mathit{running}$.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{vTaskStartScheduler} =\\ 
\mathbf{PRE}\\
\quad \mathit{scheduler} = \mathit{taskSCHEDULER\_NOT\_STARTED} \land \\
\quad \mathit{running} = \mathbf{TASK\_NULL} \land \\
\quad \mathit{blocked} = \emptyset \land \\ 
\quad \mathit{suspended} = \emptyset \land \\ 
\quad \mathit{ready} = \emptyset\\  	
\mathbf{THEN}\\
\quad \mathbf{CHOICE}\\
\quad\quad \mathit{StartScheduler} \parallel\\
\quad\quad \mathit{scheduler}:=\mathbf{taskSCHEDULER\_RUNNING}\\
\quad \mathbf{OR}\\
 \quad\quad \mathit{skip}\\
\quad \mathbf{END}\\
\mathbf{END};
 
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{vTaskStartSchedule}$}
\label{fig:vTaskStartSchedule}
\end{figure}

\subsubsection{Funcionalidades das filas de mensagens}
Para especificar as funcionalidades das fila de mensagem, que são as operações do
grupo gerênciamento de fila (sessão \ref{subsec:fmanagemente}), forma criadas
três máquinas ($\mathbf{QUEUE\_CORE}$, $\mathbf{QUEUE\_BASIC}$ e
$\mathbf{QUEUE}$ ). Na primeira máquina são especificados o conceito de tarefa e algumas
funcionalidades básica necessárias na modelagem da operação da API de
gerênciamento de fila. A segunda máquina trata de um aprimoramento, onde os
comportamentos repetitivos a maioria das funcionalidades do grupo são são
especificados em duas operações, assim as operações dessa máquina pode ser vista
como uma façada\footnote{Padrão de projeto que \ldots} que une as operações
básicas da máquina anterior em duas operações mais complexa que serão usadas na
especificação das funcionalidades. Por último, na máquina $\mathbf{QUEUE}$ é onde
são especificadas as funcionalidades em si.

\subsubsection*{QUEUE\_CORE}
A máquina $\mathbf{QUEUE\_CORE}$ é formada pelas as seguintes operações:
\begin{itemize}
  \item {\textbf{xQueueCreate} - Cria uma nova fila de mensagem retornando uma
  referência para a mesma. Se a fila não poder ser criada uma constante de
  tarefa nula $\mathbf{QUEUE\_NULL}$} é retornada no lugar da fila criada.
  \item {\textbf{sendItem} - Adiciona um novo item a uma fila e retira da fila 
  retirando da mesma uma tarefa que está na lista de espera pela chegada de um 
  item }
  \item {\textbf{receivedItem} - Remove, ou não um item de uma fila. Caso o
  item seja removido, a função retorna uma referencia para o item em
  questão, remove o item da fila e caso exista, retira uma tarefa do conjunto
  de tarefas que estão esperando por um lugar na fila }
  \item {\textbf{insertTaskWaitingToSend} - Insere uma tarefa no conjunto de
  tarefas que estão aguardando por um lugar na fila para enviar um item}
  \item {\textbf{insertTaskWaitingToRecived} - Insere uma tarefa no conjunto de
  tarefas que estão esperando pela chegada de um item na fila }
  \item {\textbf{removeFromEventListQueue} - Remove uma tarefa de todas as
  listas de eventos de todas as filas gerenciadas pelo FreeRTOS}
\end{itemize} 
\subsubsection*{$\mathbf{QUEUE\_BASIC}$}
Como dito anteriormenta, a máquina $\mathbf{QUEUE\_BASIC}$ é formada por duas
operações, $\mathit{xQueueGenericSend}$ e $\mathit{xQueueGenericReceive}$.
Essas possuem o funcionamento bastante parecido no qual é alterado apenas o
contexto de utilização das duas. Enquanto a primeira serve para enviar um intem
para uma fila, a segunda serve para retirar. Assim, a principal diferença entre
as operações é o uso das funções básicas $\mathit{SendItem}$, presente na
primeira operação e $\mathit{ReciveItem}$ presente na segunda operação. Com
isso, iremos demonstrar as especificação da operação
$\mathit{xQueueGenericSend}$.

A operação $\mathit{xQueueGenericSend}$ possui três opções de comportamento:
Enviar um item para uma fila de mensagem e caso exista, debloquear uma tarefa
no conjunto de tarefas que esperam pera chegado de um item na fila; bloquear a
tarefa atual, colocando-na na lista de tarefas que aguardam para enviar um item
para a fila; e retornar o erro de que a operação não pode ser realizada com
sucesso.

O primeiro comportamento, enviar um item para a fila de mensagem e desbloquear
uma tarefa da fila de eventos, é modelado como demonstra a figura
\ref{fig:xQueueGenericSend-1}. Nela primeiro pega-se uma tarefa contida no
conjunto $\mathit{queue\_receiving}$ da fila em questão. Em seguida, o item e a
tarefa escolhida são enviados para a operação $\mathit{sendItem}$ para que o item
possam ser enviados e a tarefa possa ser retirada do conjunto
$\mathit{queue\_receiving}$. Por ultimo, a tarefa é desbloquead com a chamada ao
método $\mathit{Unblock}$ (sessão \ref{subsubsec:tutilities}).


\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\ldots\\
\mathbf{ANY}\\
\quad  \mathit{task}\\
\mathbf{WHERE} \\
\quad  \mathit{task}\in \mathit{TASK} \land \\ 
\quad  \mathit{task}\in\mathit{blocked} \land \\ 
\quad  \mathit{task} \in \mathit{queue\_receiving}(\mathit{pxQueue})\\ 		
\mathbf{THEN}\\
\quad \mathit{sendItem}(\mathit{pxQueue},
		\mathit{pvItemToQueue},\mathit{task},\mathit{copy\_position}) \parallel\\ 
\quad\mathit{Unblock}(\mathit{task})\parallel\\
\quad\mathit{return}:=\mathit{pdPASS}\\
\mathbf{END}\\
\ldots
 
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{xQueueGenericSend}$}
\label{fig:xQueueGenericSend-1}
\end{figure}


Os comportamentos de bloquear a tarefa atual e retorno de erro são especificado
de acordo com a figura \ref{fig:xQueueGenericSend-2}. Através dela pode-se ver
que para bloquear a tarefa utual é feita apenas a chamada ao método
$\mathit{DelayTask}$. E para informar que a operação não foi realizada com
sucesso a operação apenas retorna a constante $\mathbf{errQUEUE\_FULL}$,
indicando um erro de fila cheia

 
\begin{figure}[!h]
\begin{small}


$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\ldots\\
\mathit{insertTaskWaitingToSend}(\mathit{pxQueue},\mathit{running})\parallel\\ 
\mathit{DelayTask}(\mathit{xTicksToWait})\parallel\\
\mathit{return}:=\mathbf{pdTRUE}\\
\ldots\\
\mathit{return}:=\mathbf{errQUEUE\_FULL}\\	
\ldots\\
\end{array}
\end{array}
$$
\end{small}
\caption{Continuação da modelagem da operação $\mathit{xQueueGenericSend}$}
\label{fig:xQueueGenericSend-2}
\end{figure}



	
\section{Considerações finais}
\label{sec:consideracoes} 
[Falar sobre as dificuldades encontradas na modelagem, como também a
inviabilidadede modelar um sistema de natureza concorrente no formalismo B]


\section{Trabalhos Futuros}
[Falar sobre o que pretende-se fazer nos futuros refinamentos. Como
especificar a característica de prioridade para o conceito de tarefa]



\bibliography{UFRN-DIMAp-2006-100-RT}



\end{document}
