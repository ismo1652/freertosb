%% LyX 1.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[brazil,ruledheader]{abnt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}

\input{commands}

\makeatletter
\usepackage{babel}

\makeatother
\begin{document}

\autor{Stephenson de S. L. Galvão}


\titulo{Modelagem do Sistema Operacional de Tempo Real FreeRTOS}

\orientador{Prof. Dr. David Déharbe}


\comentario{Qualificação de mestrado apresentada ao programa de Pós-gradução em
Sistemas e Computação do Departamento de Informática e Matemática Aplicada da
Universidade Federal do Rio Grande do Norte, como requisito parcial para a
obtenção do grau de Mestre em Ciências da Computação.}


\instituicao{Universidade Federal do Rio Grande do Norte \par Centro de
Ciências Exatas e Da Terra \par Departamento de Informática e Matemática
Aplicada \par Programa de Pós-Graduação em Sistemas e Computação}


\local{Natal - Rn, Brasil}


\data{1 de junho de 2009}

\capa

\folhaderosto

%\begin{folhadeaprovacao}
%Monografia de Projeto Final de Graduação sob o título
%\textit{``\ABNTtitulodata''}, defendida por \ABNTautordata~e aprovada em
%\ABNTdatadata, em Vitória, Estado do Espírito Santo, pela banca examinadora
%constituída pelos professores: \setlength{\ABNTsignthickness}{0.4pt}

%\assinatura{Prof. Msc. Sérgio A. A. de Freitas\\ Orientador} \assinatura{Prof.
%Dr. Flávio Miguel Varejão\\ Universidade Federal do Espírito Santo}
%\assinatura{Prof. Dr. Raul Henriques Cardoso Lopes\\ Universidade Federal do
%Espírito Santo}
%\end{folhadeaprovacao}
%\begin{resumo}
%Escreva aqui o texto do seu resumo.
%\end{resumo}
%\begin{abstract}
%Write here the English version of your {}``Resumo''.
%\end{abstract}

%\chapter*{Dedicatória}

%Dedico este trabalho a ...


%\chapter*{Agradecimentos}

%Agradeço a ...

\tableofcontents{}\listoffigures



\listoftables


\chapter{Introdução\label{cap:introducao}}

Falar dos grandes desafios (SBC) e do desafio do compilador ``Verifiging
compile'', ``Verified Software repository'' desafio de Jim Woodcock

\section{Objetivos}
Falar do objetivo da dissertação e não só da qualificação. Items a serem
discutidos:

\begin{itemize}
  \item Abragência da especificação
  \item Profundidade em aspectos pelo menos da construção do software
  \item Se necessário tem a possibilidade de estessão até o nível de assemblagem
		devido aos códigos em assembler que compoem o FreeRTOS.
\end{itemize}

\section{Metodologia}
Métodologia da dissertação, no contexto do que já foi feito



%item \textbf{Assunto:}
%\begin{itemize}
%  \item Motivação do trabalho
%  \item Falar do uso dos sistemas de tempo real
%  \item Falar da importância dos sistemas de tempo real
%  \item Falar da utilização dos STRs em aplicações críticas 
%  \item Demonstrar exemplos de sistemas de tempo real
%\end{itemize}

%\item \textbf{Bibliografia ou Inspirações:}
% \begin{itemize}
%  \item Introdução do artigo do semish 2009
%  \item Introdução do Relatório Técnico
%  \item Livros de STR que falam da sua importância e utilização
%\end{itemize}



\newpage


\chapter{FreeRTOS}

O FreeRTOS é um sistema operacional de tempo real enxuto, simples e de fácil uso.
O seu código fonte, feito em \textit{C} com partes em \textit{assembly}, é aberto
e possui pouco mais de 2.200 linhas de código, que são essencialmente
distribuídas em quatro arquivos: \texttt{task.c}, \texttt{queue.c},
\texttt{croutine.c} e \texttt{list.c}. Uma outra característica marcante desse
sistema está na sua portabilidade, sendo o mesmo oficialmente disponível para 17
arquiteturas monoprocessadores diferentes, entre elas a PIC, ARM e Zilog Z80,
as quais são amplamente difundidas em produtos comerciais através de sistemas
computacionais embutidos.

Como a maioria dos sistemas operacionais de tempo real, o FreeRTOS provê para os
desenvolvedores de  sistemas concorrentes de tempo-real acesso aos recursos de
\textit{hardware}, facilitando com isso o desenvovimento dos mesmo. Assim,
FreeRTOS trabalha como na figura \ref{fig:rtos}, fornecendo uma camada de
abstração localizada entre a aplicação e o hardware, que tem como papel esconder
dos desenvolvedores de aplicações os detalhes do hardware que será utilizado.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.8]{../fig/rtos.jpg}
\caption{Camada abstrata proporcionada pelo FreeRTOS}
\label{fig:rtos}
\end{figure}

Para prover tal abstração o FreeRTOS é composto por um conjunto de bibliotecas de
tipos e funções que devem ser linkeditadas\footnote{} com o código da aplicação a
ser desenvolvida.  Juntas, essas bibliotecas fornecem para o desenvolvedor
serviços como gerenciamento de tarefa, comunicação e sincronização entre tarefas,
gerenciamento de memória e controle dos dispositivos de entrada e saída.

A criação de uma aplicação utilizando o FreeRTOS pode ser divida em duas partes.
Na primeira parte são criadas, de acordo com modelos fornecidos pelo FreeRTOS, as
tarefas e demais \textbf{estruturas de controle} que serão utilizadas pela a
aplicação. Na segunda parte é feito o cadastramento das tarefas utilizadas pelo o
sistema assim como a inicialização do mesmo. Por fim, o sistema é
\textbf{compilado} para arquitetura desejada.

A seguir serão detalhadas os principais serviços providos pelo o
FreeRTOS junto com a biblioteca que disponibiliza tão serviço. Após isso será
também demonstrado como é criada uma aplicação utilizando o FreeRTOS

\section{Gerenciamento de Tarefas e CoRotinas}
\subsection{Tarefa}
Para entender como fuciona o gerenciamento de tarefas do FreeRTOS é necessário
primeiramente entender-se o conceito de tarefa. Uma tarefa é uma unidade básica
de execução que compõem as aplicações, as quais geralmente são multitarefas.
Para o FreeRTOS uma tarefa é composta por :

\begin{itemize}
  \item Um estado que demonstra a atual situação da tarefa
  \item Uma prioridade que varia de zero até uma constante máxima definida pelo
  o usuário
  \item Uma pilha naqual é armazenada o ambiente de execução (estado dos
  restradores) da tarefa quando está é interrompida
\end{itemize}

Os possível estados que uma tarefa pode assumir são :

\begin{itemize}
  \item \textbf{Em execução}: Indica que a tarefa esta sendo execultada pelo
  processado
  \item \textbf{Pronta}: Indica que a tarefa está pronta para entrar em execução
  mas não está sendo executada
  \item \textbf{Bloqueada}: Indica que a tarefa esta esperando por algum evento
  para continuar a sua execução
  \item \textbf{Suspensa}:Indica que a tarefa foi suspensa pelo kernel
  através da chamada de uma funcionalidade usada para controlar as tarefas 
\end{itemize}

A permutação que ocorre entre os estados de uma tarefa funciona como demonstra a
figura \ref{fig:task_states}. Nela uma tarefa com o estado ``em execução'' pode
ir para o estado pronta, bloqueado ou suspenso, uma tarefa com o estado pronto
pode ser suspensa ou entrar em execução e as tarefa com o estado bloqueada ou
suspensa só podem ir para o estado pronto. 

Entranto, vale enfatizar que por tratar-se de um SOTR para arquiteturas
monoprocessadores o FreeRTOS não permite que mais de uma tarefa seja executada
no mesmo momento. Assim no FreeRTOS apenas uma tarefa pode assumir o estado
pronto em um determinado instante, restando as demais os outros estado. Com
isso, para decidir qual tarefa deve ser executada existe um mecanismo no
sistema operacional denominado escalonador, o qual será detalhado na sessão
\ref{sec:escalonador}.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{../fig/task_states.jpg}
\caption{Grafo de estados de uma tarefa}
\label{fig:task_states}
\end{figure}

\subsubsection{Tarefa Ociosa}
\label{subsubsection:tarefa_ociosa}
No FreeRTOS existe também uma tarefa denominada de tarefa ociosa, a qual é
executada quando nenhuma tarefa está em execução. A tarefa ociosa tem como
principal finalidade excluir da memória tarefas que não serão mais usadas pelo
sistema. Assim quando uma aplicação informa para o sistema que uma tarefa não
será mais utilizada essa tarefa só será excluida quando a tarefa ociosa entrar
em execução. A tarefa ociosa possui a menor prioridade dentre as tarefas que
compoem um sistema.

\subsection{Escalonador de Tarefas}
\label{sec:escalonador}
O escalonador é a parte mais importante de um sistema. É ele quem decide qual
tarefa deve entrar em execução e realiza entre a tarefa que está no processador,
ou seja em execução, com a nova tarefa que ira ocupar o processador, a tarefa
que irá entrar em execução. No FreeRTOS o escalonador pode funcionar de três
modos diferentes :

\begin{itemize}
  \item \textbf{Preemptivo}: Quando o escalonador interrompe a tarefa em
  execução mudando o seu estado e ocupa o processador com outra tarefa
  \item \textbf{Cooperativo}: Quando o escalonador não tem permissões de
  interromper a tarefa em execução, tendo que esperar a mesma interromper a sua
  execução para que ele possa decidir qual será a próxima tarefa que irá entrar
  em execução e realizar a troca das mesmas.
  \item \textbf{Híbrido}:  Quando o escalonador pode comporta-se tanto como
  preemptivo como cooperativo.
\end{itemize}

Para as tarefas o escalonador funciona de forma preemptiva, sendo que a decisão
de qual tarefa deve entrar em execução e baseada na prioridade e segue a seguinte
política: a tarefa em execução deve ter prioridade maior ou igual a tarefa de
maior prioridade com o estado ``pronta''. Assim sempre que uma tarefa, com
prioridade maior que a tarefa em execução, entrar no estado pronto, ele deve
imediatamente entrar ``em execução''. Um exemplo claro da política preemptiva de
prioridade discutida acima pode de visto na figura \ref{fig:scheduler}, naqual
três tarefas, em ordem crescente de prioridade, disputam a execução do
processador.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{../fig/scheduler.jpg}
\small{
\begin{enumerate}
  \item Tarefa 1 entra no estado pronto, como não há nenhuma tarefa em execução
  esta assume controle do processador entrando em execução
  \item Tarefa 2 entra no estado pronto, como está tem prioridade maior do que
  a tarefa 1  ela entra em exução passando a tarefa 1 para o estado pronto
  \item Tarefa 3 entra no estado pronto, como está tem prioridade maior do que
  a tarefa 2  ela entra em exução passando a tarefa 2 para o estado pronto
  \item Tarefa 3 encerra a sua execução, sendo a tarefa 2 escolhida para entrar
  em execução por ser a tarefa de maior prioridade no estado pronto
  \item Tarefa 2 encerra a sua execução e o funcionamento do escalonador é
  passado para a tarefa 1
\end{enumerate}
}
\caption{Funcionamento de um escalonador preemptivo baseado na prioridade}
\label{fig:scheduler}
\end{figure}

\subsection{Corotinas}
Outro conceito importante suportado pelo FreeRTOS é o de Corotina. Como as
tarefas corotinas são unidades de execução independentes que formam uma
aplicação. Por isso assim como as tarefas, uma corotina é formada por uma
prioridade um estado, sendo a principal diferença entre uma corotina e uma
tarefa a falta de uma pilha para armazenar o contexto de execução, a qual está
presente nas tarefas e nas corotinas não.

Os estados que uma corotina pode assumir são:
\begin{itemize}
  \item \textbf{Em execução}: Quando a corotina está sendo executada
  \item \textbf{Pronta}: Quando a corotina está pronta para ser executada mas
  não está em execução
  \item \textbf{Bloqueada}: Quando a corotina esta bloqueada esperando por
  algum evento para continuar a sua execução. 
\end{itemize}

As transições entre os estados de uma corotina ocorre como demonstra a figura
\ref{fig:croutine_states}. Nela uma corotina em execução pode ir tanto para o
estado bloqueado como para o estado suspenso, uma corotina de estado bloqueado
só pode ir para o estado pronto e uma corotina de estado pronto só pode ir para
o estado ``em execução''. 

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{../fig/croutine_states.jpg}
\caption{Grafo de estados de uma corotina}
\label{fig:croutine_states}
\end{figure}

Assim como nas tarafes, a decisão de qual corotina irá entrar em execução é
feita pelo o escalonador. Para as corotinas o escalonador funciona de forma
cooperativa e baseada na prioridade. Com isso, a corotina em execução é
quem decide o momento de sua interrupção, sendo que a próxima corotina a entrar
em execução será a de maior prioridade entre as corotinas com o estado pronto

\subsection{Bibliotecas}

Para disponibilizar as caraterísticas discutidas nesta seção o FreeRTOS disponhe
das seguintes bibliotecas: Criação de Tarefas, Controle de Tarefas, Utilidades de
Tarefas, Controle do Kernel e Corotinas. A seguir tem-se em detalhe a descrição
de cada uma dessas bibliotecas junto com as funcionalidades que cada uma delas
disponibiliza

\subsubsection{Criação de Tarefas}
Essa biblioteca é responsável pelo conceito de tarefa. Nela estão presente um
tipo responsável por representar uma tarefa do sistema e duas funcionalidades uma
para a criação de uma tarefa e outra para a remoção de uma tarefa do sistema. Em
seguida tem-se uma lista com todas os tipos e funcionalidades disponibilizados
por essa biblioteca.

\begin{itemize}
  \item \textbf{xTaskHandle} - Tipo pelo qual uma tarefa e referenciada. Por
  exemplo quando uma tarefa é criada através do método \textit{xTaskCreate} ela
  é retornada pela método através do tipo \textit{xTaskHandle}
  \item \textbf{xTaskCreate} - Funcionalidade usada para criar uma nova tarefa
  para o sistema.
  \item \textbf{vTaskDelete} - Funcionalidade usada para indicar que uma tarefa
  deve ser removida do sistema\footnote{A verdadeira remoção de uma tarefa do
  sistema só é feita pela tarefa ocisa \ref{subsubsection:tarefa_ociosa}, nesse
  método é apenas indicado para o sistema qual tarefa deve ser removida}
\end{itemize}

\subsubsection{Controle de tarefas}
A biblioteca de controle de tarefas realiza determinadas operações sobre as
tarefas do sistema. Ela disponiliza funcionalidades capazes de bloquear,
suspender e retornar uma tarefa do estado suspenso, além das funcionalidades de
alterar e informar a prioridade de uma determinada tarefa. A lista das
principais funcionalidades presentes nessa biblioteca pode ser vista a seguir:

\begin{itemize}
  \item \textbf{vTaskDelay} - Método usada para suspender uma tarefa por um
  determinado tempo. Nesse método, para calcular quando será o tem que a tarefa
  deve acordar, é levando em consideração o tempo relativo, ou seja, o tempo que
  o método foi chamado. E por isso, é uma método não indicado para a criação de
  tarefas cíclicas, pois o tempo que o método é chamado pode variar em cada
  execução da tarefa devido as interrupções que a mesma pode sofrer.
  \item \textbf{vTaskDelayUntil} - Método usado para suspender uma tarefa por
  um determinado tempo. Esse método difere do \textit{vTaskDelayUntil} pelo o
  qual do tempo em que a tarefa deve ser retornada, pois nesse é levado em
  consideração o tempo em que uma tarefa foi retornada. Assim, se ocorrer uma
  interrupção o tempo que a tarefa foi retornada não ira mudar, podendo criar
  assim uma tarefa com intervalos iguais de execução chamada de tarefa cíclica
  \item \textbf{uxTaskPriorityGet} - Método usado para informar prioridade de
  uma determinada tarefa
  \item \textbf{vTaskPrioritySet} - Método usado mudar a prioridade de uma
  determinada tarefa
  \item \textbf{vTaskSuspend} - Método usado para suspender uma determinada
  tarefa
  \item \textbf{vTaskResume} - Método usado retornar uma tarefa
\end{itemize}

\subsubsection{Utilitários de tarefas}
É atravé dessa biblioteca que o FreeRTOS diponibiliza para o usuário informações
importantes a respeito das tarefas e do escalonador do sistema . Nela estão
prensentes funcionalidades com a de retornar uma referência para a utual tarefa
em execução, retornar o tempo de funcionamento e o estado do escalonador e
retornar o número e a lista das tarefas que estão sendo gerenciadas pelo
sistema. Uma listagem das principais funcionalidades dessa biblioteca é
encontrada a seguir:

\begin{itemize}
  \item \textbf{xTaskGetCurrentTaskHandle} - Retorna a uma referência para
  atual tarefa em execução
  \item \textbf{xTaskGetTickCount} - Retorna o tempo decorrido desde a
  inicialização do sistema
  \item \textbf{xTaskGetSchedulerState} - Retorna o estado do escalonador 
  \item \textbf{uxTaskGetNumberOfTasks} - Retorna o número de tarefas do sistema
  \item \textbf{vTaskList} - Retorna uma lista de tarefas do sistema
\end{itemize}
\subsubsection{Controle do Escalonador}
Nessa biblioteca estão presentes as funcionalidades responsáveis por controlar
as atividades do escalonador do sistema. Nela encontramos funcionalidades
responsáveis por inicializar e finalizar as atividades do escalonador, assim
como, suspender e retornar a atividades do mesmo. As principais funcionalidades
presente nessa biblioteca são :

\begin{itemize}
  \item \textbf{vTaskStartScheduler} - Método que inicia as atividades do
  escalonador. Usado para a inicialização do sistema
  \item \textbf{vTaskEndScheduler} - Método que termina as atividades do
  escalonador. Usado para a finalização das atividades do sistema também 
  \item \textbf{vTaskSuspendAll} - Método que suspende as atividades do
  escalonador
  \item \textbf{xTaskResumeAll} - Método que retorna as atividades de uma
  escalonador suspenso
  
\end{itemize}

\section{Comunicação e sicronização entre tarefa}
Frequentemente tarefas necessitam se um com as outras. Por exemplo a tarefa A
depende da leitura do teclado feito pela tarefa B. Com isso a uma necessidade
de que está comunição sejá feita de maneira bem estruturada e sem interrupções.
Devido a isso a maiorida dos sistemas operacionais oferencem vários tipos de
comunicação entre as tarefas. Que podem ocorrer da seguinte forma: uma tarefa
deseja passar informações para outra, duas ou mais tarefas querem utilizar o
mesmo recurso e uma tarefa dependo do resultado produzido por outra tarefa.

No FreeRTOS assim como na maioria dos sistemas operacionais os mecanismos
responsáveis pela a comunicação entre as tarefas são a fila de mensagem, o
semáforo e o mutex (Mutal Excluision). Para entender melhor como funciona a
comunicação entre tarefas no FreeRTOS, cada um desses mecanismo será detalhado
a seguir

\subsection{Fila de Mensagens}

Filas de mensagens são estruturas primitivas de comunicação entre tarefas. Elas
funcionam como, demonstra a figura \ref{fig:fila_de_mensagens}, um túnel no qual
tarefas enviam e recebem mensagem. Assim quando uma tarefa necessita comunicar-se
com outra primeiramente ela envia uma mensagem para o túnel para que a outra
tarefa, quando entrar em execução possa ler a mensagem enviada.
 

\begin{figure}[!h] \centering
\includegraphics[scale=0.6]{../fig/croutine_states.jpg}
\caption{Funcionamento de uma fila de mensagens}
\label{fig:fila_de_mensagens}
\end{figure} 
 
 
No FreeRTOS, uma fila de mensagens é formada por uma lista de tamanho fixo que
armazena as mensagens,também de tamanhos fixos, enviadas para a lista. Assim,
quando uma mensagem é envida para uma fila, uma cópia dela é armazenada na lista
de mensagens para que outra tarefa possa utiliza-la. Entranto, no lugar de copiar
toda mensagem para a lista de mensagens, é possível também armazenar-se apenas
uma referência para a mesma, o que torna mais complicado um trabalho do
desenvolvedor, pois assim o acesso à mensagem ficará compartilhado entre as
tarefas, necessitando com isso de uma estrutura de sicronização para coordenar a
utilização da mensagem pelas tarefas.

Além da lista de mensagens uma fila de mensagens é composta por mais duas
outras lista, uma para armazenar as tarefas que estão aguardando enviar uma
mensagens para a fila e outra para armazenar as tarefas que estão aguardando
receber uma mensagem da fila. Assim, quando uma tarefa tenta enviar uma
mensagem para uma fila cheia esta é bloqueada e colocada na lista de tarefa
aguardam para enviar uma mensagem para fila até que um lugar na fila sejá
liberado. O mesmo acontece quando uma tarefa tenta ler uma mensagem de uma fila
vazia.

O FreeRTOS, disponibiliza para o usuário funcionalidades é possíveis de definir o
tempo máximo que uma tarefa pode ficar bloqueada esperado por uma fila (liberação
de espaço ou chega de mensagem). E no caso em que existem mais de uma tarefa
bloqueadas aguardando por um evento de uma fila, as tarefas de maior prioridade
têm preferência sobre as demais.

\subsection{Semáforo}
Semáforos são mecanismos usados na sincronização entre tarefas. Eles funcionam
como uma chave que libera, ou não, o uso de um determinado recurso. Assim quando
uma tarefa deseja acessar um recurso compartilhado, ela primeiramente deve
solicitar o semáforo que coordena o uso do recurso, caso o semáforo esteja
liberado, a tarefa tem a permissão de utilizar o recurso e, em seguida, libera o
semáforo, caso contrário, a tarefa é bloqueada até que o semáforo seja liberado.

O FreeRTOS disponibiliza dois tipo de semáforos: os semáforo binário e o semáforo
de contador. A diferença entre os dois está apenas no número de tarefas que podem
reter o semáforo ao mesmo tempo. No semáforo binario apenas uma tarefa pode reter
o semáforo e acessar o recurso compartilhado. E no semáforo com contador existe
um número fixo de tarefa que podem reter o semáforo, sendo esse número definido
na criação do semáfor e controlado pelo contador. Assim no semáforo com contador
para cada tarefa que retem o semáforo o contador é decrementado de um e para cada
tarefa que libera o semáforo o contador é incrementado, sendo que o semáforo
torna-se indisponível quando o contador for igual a zero.

No FreeRTOS o semáforo binário funciona como uma fila de mensagens com um único
item. Assim, quando a fila estiver vazia, indica que o semáforo está sendo usado
e, quando a fila estiver cheia, indica que o semáforo está liberado. O mesmo
ocorre para o semáforo com contador, só que nesse caso, o tamanho da fila será a
quantidade de tarefas que podem reter o semáforo ao mesmo tempo.

\subsection{Mutex}

Mutex são parecidos com o semáforo binário. A única diferença entre os dois é que
o mutex implementa um mecanismo de herança de prioridade, o qual impede que uma
tarefa de maior prioridade fique bloqueada a espera de um semáforo ocupado por
uma tarefa de menor prioridade, causando o que chamamos de inversão de
prioridade.

O mecanismo de herança de prioridade funciona da seguinte forma, quando uma
tarefa solicita o semáforo ele verifica se a tarefa solicitante possui prioridade
maior que a tarefa com o semáforo. Caso afirmativo, a tarefa que retém o semáforo
tem, momentaneamente, a sua prioridade elevada, para que assim ela possa realizar
a suas funções sem interrupções e, conseqüentemente, liberar mais rapidamente o
semáforo.

\subsection{Bibliotecas}
A característica de comunicação e sicronização entre tarefas está dividida em
duas bibliotecas, Gerenciamento de fila de mensagens e Semáforo/Mutex. A seguir
tem-se a explicação de cada uma dessas bibliotecas.

\subsubsection{Gerencialmente de fila de Mensagens}
A biblioteca gerenciamento de fila de mensagens é responsável pela criação e
utilização da estrutura fila de mensagens. Ela é composta por funcionalidades que
instanciam e removem fila de mensagens do sistema assim como também
funcionalidades que enviam/recebem mensagens para/de uma fila de mensagens
desejada. Abaixo tem-se uma lista com as principais funcionalidades dessas
biblioteca.

\begin{itemize}
  \item \textbf{xQueueCreate} - Cria uma instância de uma nova fila de
  mensagens no sistema
  \item \textbf{vQueueDelete} - Remove uma fila de mensagem do sistema
  \item \textbf{xQueueSend} - Envia um mensagem para a fila 
  \item \textbf{xQueueSendToBack} - Envia uma mensagem para o fim da fila  
  \item \textbf{xQueueSendToFront} - Envia uma mensagem para o inicio da fila
  \item \textbf{xQueueReceive} - Ler e remove uma mensagem da fila 
  \item \textbf{xQueuePeek} - Apenas ler uma mensagem da fila
\end{itemize}

\subsubsection{Semáforo/Mutex}
Na biblioteca de semáforo e mutex são implementadas as características de
sicronização entre tarefas, ou seja, os mecanísmo de semáforo e mutex junto com
as suas operações. Assim nessa biblioteca estão presentes funcionalidades que
criam e removem semáforos e mutex, além das funcionalidades que solicitam e
liberam os semáforos e os mutex. As principais funcionalidades dessa biblioteca
pode ser vista a seguir.


\begin{itemize}
  \item \textbf{vSemaphoreCreateBinary} - Cria um semáforo binário
  \item \textbf{vSemaphoreCreateCounting} - Cria um semáforo com contador 
  \item \textbf{xSemaphoreCreateMutex} - Cria um mutex 
  \item \textbf{xSemaphoreTake} - Solicita a retensão de um semáforo ou de um
  mutex
  \item \textbf{xSemaphoreGive} - Libera um semáforo ou um mutex retido
\end{itemize}


\section{Criação de uma aplicação utilizando o FreeRTOS}

Para construir uma aplicação de tempo real utilizando o FreeRTOS o desenvolvedor
deve seguir determinadas restrições imposta pelo sistema operacional para a
aplicação desenvolvida possa funcionar coretamente. Entre essas restrições
estão alguns parâmetros de configurações contento informações sobre o hardware,
como tamanho da memória e velocidade clock, assim como restrições de templates
para a criação de determinadas estruturas utilizadas pela a aplicação, como
tarefas e fila de mensagem. Entretanto, para facilitar o trabalho e o
entendimento do desenvolvedores iniciantes o FreeRTOS disponibilizou junto com
seu código fonte várias aplicações exemplos que devem ser tomadas como base
para o desenvolvimento de novas aplicações. Nelas são encontrados vários tipos
de configurações diferentes para cada arquitetura alvo suportada, assim como
vários padrões que tornam o desenvolvimento de aplicações através do FreeRTOS
uma tarefa mais simples.

Contudo explicar detalhadamente como é desenvolvida um novo sistema utilizando
o FreeRTOS foge do escopo desse capítulo, que tem como objetivo realizar uma
pequena introdução ao Sistema Operacional de Tempo Real. Assim, com o objetivo
finalizar uma introdução a explicação sobre o FreeRTOS e demonstrar como as
bibliotecas do sistema são utilizadas para a criação de uma nova aplicação,
nessas seção será demonstrada uma explicação didática de como é criada uma
aplicação no FreeRTOS.


Para criar-se uma aplicação no FreeRTOS deve-se inicialmente defenir e
implementar as tarefas que são execultadas pela a aplicação. 



  

Inicialmente a construção de novas aplicações utilizando o FreeRTOS é feita
através de modificações em exemplos disponibilizados junto com o seu código
fonte. Assim o desenvolvedor 

Com dito no inicio do capítulo, o FreeRTOS é um simples e portável, sendo o mesmo
compatível com várias arquiteturas diferentes. Ele disponibiliza, junto com seu
código fonte, exemplos de aplicações para vários tipos de arquiteturas
diferentes. Inicialmente essas aplicações servem como base para o
desenvolvimento de novos sistemas, pois vários detalhes como configuração do
hardware e utilização ou não de certo recurso pelo o sistema já vem
pre configurados nesses exemplos, sendo necessário o desenvolvedor apenas 
 
 
Entretanto,

demonstrar detalhamente como é construida uma aplicação no FreeRTOS foge do
escopo desse trabalho. Desse


\chapter{Método B}

Métodos Formais trata-se de uma abordagem formal para a especificação e
construção de sistemas computacionais. Eles utilizam-se de conceitos
matemáticos sólidos como lógica de primeira ordem e teorias dos conjuntos para
a criação e verificação de sistemas consistentes, seguros e sem ambiguidades.
Devido a sua rigosa construção os métodos formais tem sido bastante utilizados
na criação de sistemas críticos como industria aeronaltica, programas médicos e
programas lidam enormes valores monetários.

O método B trata-se de uma abordagem formal usado para especificar e construir
sistema computacionais seguros. Ele foi criado por Jean-Raymond Abrial, com a
colaboração de outros pesquisadores da universidade de Oxford. Na sua criação
foram reunidaes várias qualidades presentes nos demais método formais. Entre elas
estão as pré e pós condições, condições necessárias para a execução de um método
e alcançadas após a execução do mesmo, mudularização, abstração e refinamento,
estratégia de construção/especificação de sistemas através de vários níveis de
abstração.

o método B proporciona uma criação de sistemas através de sucessiveis níveis de
abstração, na qual inicialmente cria-se um modulo abstrato em uma linguagem de
modelagem. Esse módulo é refinado através de vários outros módulos até chegar em
uma linguagem algorítmica, denominada B0, que pode ser traduzida automaticamente
em algumas linguagem de programação imperativa com C, Ada, Java, JavaCard e C\#.

Cada módulo criado no desenvolvimento do sistema com o método B deve ser
analisado estaticamente para saber se ele é implementável ou consistente, ou
seja, que sua execução não leve a um estado não permitido pela especificação.
Assim como também cada nível de abstração deve ser analisado estaticamente para
saber se ele é coerente com o nível acima.

Atualmente o desenvolvimento de sistemas utilizando o método B pode ser apoiado
por diversas ferramentas que vão desde a analise estática da especificação até a
geração de código executável. Devido a isso, o método B utrapassou a barreira
acadêmica e passou a ser bastante difundido na indústria de sistemas críticos,
principalmente na industrias ferroviárias e automobilistica, sendo utilizado em
sistemas que atuam no metro de Paris e em subsistemas dos automóveis da Peugeot.


\section{Notação de Máquina Abstrata}

A base do método B está na notação de máquina abstrada(em inglês:
\textit{Abstract Machine Notation} - AMN) a qual disponibiliza um framework comum
para a especificação e contrução de sistemas, permitindo também a verificação
estática do mesmo.  Mais especificamente, a AMN trata-se de uma liguagem de
especificação de sistemas formada por moódulos básicos de construção chamados de
Máquina Abstrata ou simplemente Máquina. 

Cada Máquina Abstrata é composta por diferentes seções, sendo que cada seção é
responsável por definir um aspecto da especificação do sistema como: parâmetros,
tipos, constantes, variáveis de estado, estados iniciais e transições do sistema.
Como, por exemplo, a figura~\ref{fig:tarefas_maquina} contém uma Máquina
Abstrata, chamada \textit{Kernel}, a qual especifica um sistema que permite
incluir e excluir tarefas até o limite de 10 tarefas e possui as seguintes
seções:


\begin{description}
\item[MACHINE] Nessa seção inicia-se
o código da máquina abstrata. Ela identifica a natureza e o nome do módulo,
seguido opcionalmente por um ou mais parâmetros separados por vírgula e
limitados por parenteses
\item[SETS] introduz um novo tipo de entidade, no exmplo é
  $\mathit{TASK}$. Nesse momento, nenhum detalhe é fornecido quanto à
  maneira como essa entidade será implementada.
\item[VARIABLES] informa o nome das diferentes variáveis que compoem o estado.
No exemplo, apenas há uma variável de estado: $\mathit{tasks}$.
\item[INVARIANT] especifica o tipo das variáveis de estado assim
  também como os estados válidos do sistema. Aqui, $\mathit{tasks}$ é
  um conjunto de até 10 elementos do tipo $\mathit{TASK}$. A
  caracterização lógica do conjunto dos estados válidos é uma das
  atividades mais importantes da especificação.
\item[INITIALISATION] identifica quais são os possíveis estados
  iniciais do sistema. No caso, $\mathit{tasks}$ é o conjunto vazio.
\item[OPERATIONS] determina os diferentes tipo de eventos que o
  sistema pode sofrer. No nosso exemplo, temos operações para
  adicionar e eliminar um elemento de $\mathit{tasks}$. Uma operação
  pode ter parâmetros, resultados e pode alterar o valor de variáveis
  de estado. Um ponto importante encontrados nas operações são as précondições,
  a quais são condições que devem ser satisfeitas para que a operaçõas seja
  realizada
\end{description}  
\begin{figure}[!ht]
\begin{small}

$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\MACHINE\\
\quad \mathit{Kernel}\\
    
\SETS\\
\quad \mathit{TASK}\\
    
\VARIABLES\\
\quad \mathit{tasks}\\
    
\INVARIANT\\
\quad \mathit{tasks} \in \pow(\mathit{TASK}) \land \\
\quad \card(\mathit{tasks})\leq 10\\
    
\INITIALISATION\\
\quad \mathit{tasks}:=\emptyset\\
    
\end{array}
\begin{array}[t]{l}
\OPERATIONS\\\\
\mathit{task\_add}(\mathit{task}) = \\
\quad \PRE \\
\quad\quad \mathit{task}\in \mathit{TASK} \land \\
\quad\quad \mathit{task}\not\in \mathit{tasks} \land\\
\quad\quad \card(\mathit{tasks})<10\\
\quad \THEN\\
\quad\quad \mathit{tasks}:=\mathit{tasks}\cup \{\mathit{task}\}\\
\quad   \END;\\

\end{array}

\begin{array}[t]{l}
\ldots\\
\mathit{task\_delete}(\mathit{task})=\\
\quad \PRE\\
\quad \quad \mathit{task}\in \mathit{tasks}\\
\quad \THEN\\
\quad \quad \mathit{tasks}:=\mathit{tasks}-\{\mathit{task}\}\\
\quad \END\\
	
\END\\
\end{array}
\end{array}
$$
\end{small}
\caption{Maquina abstrata de tarefas}
\label{fig:tarefas_maquina}
\end{figure}

Com isso a especificação de sistemas utilizando o método B pode ser dividido em
duas partes principais, a especificação do estado da máquina e a especificação
das operações da máquina. Essas duas partes serão discutidas a seguir.

\subsection{Especificação do estado dá máquina}
O estado de uma máquina abstrata pode ser definido em termos de suas variáveis
e do seu invariante. Assim o estado de uma máquina é formado pelas as variáveis
da máquina junto com suas definições e limitações. É no estado que é defino os
estado válidos do sistema. 

No estado da máquina são especificados, por meio de calculo de predicados, da
teoria do conjunto e relações, as propriedades estáticas que o sistema deve
obedecer. Assim no exemplo da figura~\ref{fig:tarefas_maquina} o estado foi
especificado como sendo a variável $$\mathit{tasks}$$ e seu predicados
$$\mathit{tasks} \in \pow(\mathit{TASK})$$ e $$ \card(\mathit{tasks})\leq 10$$

\subsection{Especificação das operações da máquina}

Nas operações da máquina é especificado o comportamento dinâmico do sistema. É
através das operações que o estado da máquina é alterado, respeitando sempre as
restrições do estado da máquina, ou seja, as codições declaradas no invariante
dá máquina deve ser sempre satisfeita no final da operação.

falar das pre condições

\subsection{Outras seções de uma Máquina Abstrata}
\section{Obrigação de Prova}
\section{Modularização}
\section{Refinamento}





\begin{itemize}
  \item Explicar o que é o método B
  \item Explicar a base teórica de B (AMN e as substituições)
  \item Explicar como é especificado um sistema em B (como é criado um módulo)
  \item Falar das obrigações de prova
  \item Falar dos mecânismo de composição e refinamento
  \item Dizer que o refinamento pode chegar em um nível concreto que pode ser
  sintetizado para algumas linguagens de programação.
  \item Falar do uso de ferramentas
  \item Falar do projeto B2ASM
\end{itemize}

\chapter{Revisão Literária}

 \begin{itemize}
  \item Enumerar Projetos
  \item Desafio de software verificado    
 \end{itemize}







\chapter{Proposta}

\begin{itemize}
  \item Como será feita a modelagem do FreeRTOS
  \item Falar do estudo do FreeRTOS e identificação dos seus principais
  conceitos e funcionalidades
  \item O desenvolvimento progressivo acrescentando novas funcionalidades a cada
  refinamento
  \item Ligar a abordagem do compilador verificável ao FreeRTOS
  \item Dizer como será ou deve feita a união do FreeRTOS para o compilador
  verificável
\end{itemize}

\chapter{Atividades e Etapas}

\newpage

\bibliographystyle{abnt-alf}
\bibliography{quali}

\anexo

\end{document}

