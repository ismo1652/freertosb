%% LyX 1.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[brazil,ruledheader]{abnt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}

\input{commands}

\makeatletter
\usepackage{babel}

\makeatother
\begin{document}

\autor{Stephenson de S. L. Galvão}


\titulo{Modelagem do Sistema Operacional de Tempo Real FreeRTOS}

\orientador{Prof. Dr. David Déharbe}


\comentario{Qualificação de mestrado apresentada ao programa de Pós-gradução em
Sistemas e Computação do Departamento de Informática e Matemática Aplicada da
Universidade Federal do Rio Grande do Norte, como requisito parcial para a
obtenção do grau de Mestre em Ciências da Computação.}


\instituicao{Universidade Federal do Rio Grande do Norte \par Centro de
Ciências Exatas e Da Terra \par Departamento de Informática e Matemática
Aplicada \par Programa de Pós-Graduação em Sistemas e Computação}


\local{Natal - Rn, Brasil}


\data{1 de junho de 2009}

\capa

\folhaderosto

%\begin{folhadeaprovacao}
%Monografia de Projeto Final de Graduação sob o título
%\textit{``\ABNTtitulodata''}, defendida por \ABNTautordata~e aprovada em
%\ABNTdatadata, em Vitória, Estado do Espírito Santo, pela banca examinadora
%constituída pelos professores: \setlength{\ABNTsignthickness}{0.4pt}

%\assinatura{Prof. Msc. Sérgio A. A. de Freitas\\ Orientador} \assinatura{Prof.
%Dr. Flávio Miguel Varejão\\ Universidade Federal do Espírito Santo}
%\assinatura{Prof. Dr. Raul Henriques Cardoso Lopes\\ Universidade Federal do
%Espírito Santo}
%\end{folhadeaprovacao}
%\begin{resumo}
%Escreva aqui o texto do seu resumo.
%\end{resumo}
%\begin{abstract}
%Write here the English version of your {}``Resumo''.
%\end{abstract}

%\chapter*{Dedicatória}

%Dedico este trabalho a ...


%\chapter*{Agradecimentos}

%Agradeço a ...

\tableofcontents{}\listoffigures



\listoftables


\chapter{Introdução\label{cap:introducao}}

Falar dos grandes desafios (SBC) e do desafio do compilador ``Verifiging
compile'', ``Verified Software repository'' desafio de Jim Woodcock

\section{Objetivos}
Falar do objetivo da dissertação e não só da qualificação. Items a serem
discutidos:

\begin{itemize}
  \item Abragência da especificação
  \item Profundidade em aspectos pelo menos da construção do software
  \item Se necessário tem a possibilidade de estessão até o nível de assemblagem
		devido aos códigos em assembler que compoem o FreeRTOS.
\end{itemize}

\section{Metodologia}
Métodologia da dissertação, no contexto do que já foi feito



%item \textbf{Assunto:}
%\begin{itemize}
%  \item Motivação do trabalho
%  \item Falar do uso dos sistemas de tempo real
%  \item Falar da importância dos sistemas de tempo real
%  \item Falar da utilização dos STRs em aplicações críticas 
%  \item Demonstrar exemplos de sistemas de tempo real
%\end{itemize}

%\item \textbf{Bibliografia ou Inspirações:}
% \begin{itemize}
%  \item Introdução do artigo do semish 2009
%  \item Introdução do Relatório Técnico
%  \item Livros de STR que falam da sua importância e utilização
%\end{itemize}



\newpage


\chapter{FreeRTOS}

O FreeRTOS é um sistema operacional de tempo real enxuto, simples e de fácil uso.
O seu código fonte, feito em \textit{C} com partes em \textit{assembly}, é aberto
e possui pouco mais de 2.200 linhas de código, que são essencialmente
distribuídas em quatro arquivos: \texttt{task.c}, \texttt{queue.c},
\texttt{croutine.c} e \texttt{list.c}. Uma outra característica marcante desse
sistema está na sua portabilidade, sendo o mesmo oficialmente disponível para 17
arquiteturas monoprocessadores diferentes, entre elas a PIC, ARM e Zilog Z80,
as quais são amplamente difundidas em produtos comerciais através de sistemas
computacionais embutidos.

Como a maioria dos sistemas operacionais de tempo real, o FreeRTOS provê para os
desenvolvedores de  sistemas concorrentes de tempo-real acesso aos recursos de
\textit{hardware}, facilitando com isso o desenvovimento dos mesmo. Assim,
FreeRTOS trabalha como na figura \ref{fig:rtos}, fornecendo uma camada de
abstração localizada entre a aplicação e o hardware, que tem como papel esconder
dos desenvolvedores de aplicações os detalhes do hardware que será utilizado.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.8]{../fig/rtos.jpg}
\caption{Camada abstrata proporcionada pelo FreeRTOS}
\label{fig:rtos}
\end{figure}

Para prover tal abstração o FreeRTOS é composto por um conjunto de bibliotecas de
tipos e funções que devem ser linkeditadas\footnote{} com o código da aplicação a
ser desenvolvida.  Juntas, essas bibliotecas fornecem para o desenvolvedor
serviços como gerenciamento de tarefa, comunicação e sincronização entre tarefas,
gerenciamento de memória e controle dos dispositivos de entrada e saída.

A criação de uma aplicação utilizando o FreeRTOS pode ser divida em duas partes.
Na primeira parte são criadas, de acordo com modelos fornecidos pelo FreeRTOS, as
tarefas e demais \textbf{estruturas de controle} que serão utilizadas pela a
aplicação. Na segunda parte é feito o cadastramento das tarefas utilizadas pelo o
sistema assim como a inicialização do mesmo. Por fim, o sistema é
\textbf{compilado} para arquitetura desejada.

A seguir serão detalhadas os principais serviços providos pelo o
FreeRTOS junto com a biblioteca que disponibiliza tão serviço. Após isso será
também demonstrado como é criada uma aplicação utilizando o FreeRTOS

\section{Gerenciamento de Tarefas e CoRotinas}
\subsection{Tarefa}
Para entender como fuciona o gerenciamento de tarefas do FreeRTOS é necessário
primeiramente entender-se o conceito de tarefa. Uma tarefa é uma unidade básica
de execução que compõem as aplicações, as quais geralmente são multitarefas.
Para o FreeRTOS uma tarefa é composta por :

\begin{itemize}
  \item Um estado que demonstra a atual situação da tarefa
  \item Uma prioridade que varia de zero até uma constante máxima definida pelo
  o usuário
  \item Uma pilha naqual é armazenada o ambiente de execução (estado dos
  restradores) da tarefa quando está é interrompida
\end{itemize}

Os possível estados que uma tarefa pode assumir são :

\begin{itemize}
  \item \textbf{Em execução}: Indica que a tarefa esta sendo execultada pelo
  processado
  \item \textbf{Pronta}: Indica que a tarefa está pronta para entrar em execução
  mas não está sendo executada
  \item \textbf{Bloqueada}: Indica que a tarefa esta esperando por algum evento
  para continuar a sua execução
  \item \textbf{Suspensa}:Indica que a tarefa foi suspensa pelo kernel
  através da chamada de uma funcionalidade usada para controlar as tarefas 
\end{itemize}

A permutação que ocorre entre os estados de uma tarefa funciona como demonstra a
figura \ref{fig:task_states}. Nela uma tarefa com o estado ``em execução'' pode
ir para o estado pronta, bloqueado ou suspenso, uma tarefa com o estado pronto
pode ser suspensa ou entrar em execução e as tarefa com o estado bloqueada ou
suspensa só podem ir para o estado pronto. 

Entranto, vale enfatizar que por tratar-se de um SOTR para arquiteturas
monoprocessadores o FreeRTOS não permite que mais de uma tarefa seja executada
no mesmo momento. Assim no FreeRTOS apenas uma tarefa pode assumir o estado
pronto em um determinado instante, restando as demais os outros estado. Com
isso, para decidir qual tarefa deve ser executada existe um mecanismo no
sistema operacional denominado escalonador, o qual será detalhado na sessão
\ref{sec:escalonador}.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{../fig/task_states.jpg}
\caption{Grafo de estados de uma tarefa}
\label{fig:task_states}
\end{figure}

\subsubsection{Tarefa Ociosa}
\label{subsubsection:tarefa_ociosa}
No FreeRTOS existe também uma tarefa denominada de tarefa ociosa, a qual é
executada quando nenhuma tarefa está em execução. A tarefa ociosa tem como
principal finalidade excluir da memória tarefas que não serão mais usadas pelo
sistema. Assim quando uma aplicação informa para o sistema que uma tarefa não
será mais utilizada essa tarefa só será excluida quando a tarefa ociosa entrar
em execução. A tarefa ociosa possui a menor prioridade dentre as tarefas que
compoem um sistema.

\subsection{Escalonador de Tarefas}
\label{sec:escalonador}
O escalonador é a parte mais importante de um sistema. É ele quem decide qual
tarefa deve entrar em execução e realiza entre a tarefa que está no processador,
ou seja em execução, com a nova tarefa que ira ocupar o processador, a tarefa
que irá entrar em execução. No FreeRTOS o escalonador pode funcionar de três
modos diferentes :

\begin{itemize}
  \item \textbf{Preemptivo}: Quando o escalonador interrompe a tarefa em
  execução mudando o seu estado e ocupa o processador com outra tarefa
  \item \textbf{Cooperativo}: Quando o escalonador não tem permissões de
  interromper a tarefa em execução, tendo que esperar a mesma interromper a sua
  execução para que ele possa decidir qual será a próxima tarefa que irá entrar
  em execução e realizar a troca das mesmas.
  \item \textbf{Híbrido}:  Quando o escalonador pode comporta-se tanto como
  preemptivo como cooperativo.
\end{itemize}

Para as tarefas o escalonador funciona de forma preemptiva, sendo que a decisão
de qual tarefa deve entrar em execução e baseada na prioridade e segue a seguinte
política: a tarefa em execução deve ter prioridade maior ou igual a tarefa de
maior prioridade com o estado ``pronta''. Assim sempre que uma tarefa, com
prioridade maior que a tarefa em execução, entrar no estado pronto, ele deve
imediatamente entrar ``em execução''. Um exemplo claro da política preemptiva de
prioridade discutida acima pode de visto na figura \ref{fig:scheduler}, naqual
três tarefas, em ordem crescente de prioridade, disputam a execução do
processador.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{../fig/scheduler.jpg}
\small{
\begin{enumerate}
  \item Tarefa 1 entra no estado pronto, como não há nenhuma tarefa em execução
  esta assume controle do processador entrando em execução
  \item Tarefa 2 entra no estado pronto, como está tem prioridade maior do que
  a tarefa 1  ela entra em exução passando a tarefa 1 para o estado pronto
  \item Tarefa 3 entra no estado pronto, como está tem prioridade maior do que
  a tarefa 2  ela entra em exução passando a tarefa 2 para o estado pronto
  \item Tarefa 3 encerra a sua execução, sendo a tarefa 2 escolhida para entrar
  em execução por ser a tarefa de maior prioridade no estado pronto
  \item Tarefa 2 encerra a sua execução e o funcionamento do escalonador é
  passado para a tarefa 1
\end{enumerate}
}
\caption{Funcionamento de um escalonador preemptivo baseado na prioridade}
\label{fig:scheduler}
\end{figure}

\subsection{Corotinas}
Outro conceito importante suportado pelo FreeRTOS é o de Corotina. Como as
tarefas corotinas são unidades de execução independentes que formam uma
aplicação. Por isso assim como as tarefas, uma corotina é formada por uma
prioridade um estado, sendo a principal diferença entre uma corotina e uma
tarefa a falta de uma pilha para armazenar o contexto de execução, a qual está
presente nas tarefas e nas corotinas não.

Os estados que uma corotina pode assumir são:
\begin{itemize}
  \item \textbf{Em execução}: Quando a corotina está sendo executada
  \item \textbf{Pronta}: Quando a corotina está pronta para ser executada mas
  não está em execução
  \item \textbf{Bloqueada}: Quando a corotina esta bloqueada esperando por
  algum evento para continuar a sua execução. 
\end{itemize}

As transições entre os estados de uma corotina ocorre como demonstra a figura
\ref{fig:croutine_states}. Nela uma corotina em execução pode ir tanto para o
estado bloqueado como para o estado suspenso, uma corotina de estado bloqueado
só pode ir para o estado pronto e uma corotina de estado pronto só pode ir para
o estado ``em execução''. 

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{../fig/croutine_states.jpg}
\caption{Grafo de estados de uma corotina}
\label{fig:croutine_states}
\end{figure}

Assim como nas tarafes, a decisão de qual corotina irá entrar em execução é
feita pelo o escalonador. Para as corotinas o escalonador funciona de forma
cooperativa e baseada na prioridade. Com isso, a corotina em execução é
quem decide o momento de sua interrupção, sendo que a próxima corotina a entrar
em execução será a de maior prioridade entre as corotinas com o estado pronto

\subsection{Bibliotecas}

Para disponibilizar as caraterísticas discutidas nesta seção o FreeRTOS disponhe
das seguintes bibliotecas: Criação de Tarefas, Controle de Tarefas, Utilidades de
Tarefas, Controle do Kernel e Corotinas. A seguir tem-se em detalhe a descrição
de cada uma dessas bibliotecas junto com as funcionalidades que cada uma delas
disponibiliza

\subsubsection{Criação de Tarefas}
Essa biblioteca é responsável pelo conceito de tarefa. Nela estão presente um
tipo responsável por representar uma tarefa do sistema e duas funcionalidades uma
para a criação de uma tarefa e outra para a remoção de uma tarefa do sistema. Em
seguida tem-se uma lista com todas os tipos e funcionalidades disponibilizados
por essa biblioteca.

\begin{itemize}
  \item \textbf{xTaskHandle} - Tipo pelo qual uma tarefa e referenciada. Por
  exemplo quando uma tarefa é criada através do método \textit{xTaskCreate} ela
  é retornada pela método através do tipo \textit{xTaskHandle}
  \item \textbf{xTaskCreate} - Funcionalidade usada para criar uma nova tarefa
  para o sistema.
  \item \textbf{vTaskDelete} - Funcionalidade usada para indicar que uma tarefa
  deve ser removida do sistema\footnote{A verdadeira remoção de uma tarefa do
  sistema só é feita pela tarefa ocisa \ref{subsubsection:tarefa_ociosa}, nesse
  método é apenas indicado para o sistema qual tarefa deve ser removida}
\end{itemize}

\subsubsection{Controle de tarefas}
A biblioteca de controle de tarefas realiza determinadas operações sobre as
tarefas do sistema. Ela disponiliza funcionalidades capazes de bloquear,
suspender e retornar uma tarefa do estado suspenso, além das funcionalidades de
alterar e informar a prioridade de uma determinada tarefa. A lista das
principais funcionalidades presentes nessa biblioteca pode ser vista a seguir:

\begin{itemize}
  \item \textbf{vTaskDelay} - Método usada para suspender uma tarefa por um
  determinado tempo. Nesse método, para calcular quando será o tem que a tarefa
  deve acordar, é levando em consideração o tempo relativo, ou seja, o tempo que
  o método foi chamado. E por isso, é uma método não indicado para a criação de
  tarefas cíclicas, pois o tempo que o método é chamado pode variar em cada
  execução da tarefa devido as interrupções que a mesma pode sofrer.
  \item \textbf{vTaskDelayUntil} - Método usado para suspender uma tarefa por
  um determinado tempo. Esse método difere do \textit{vTaskDelayUntil} pelo o
  qual do tempo em que a tarefa deve ser retornada, pois nesse é levado em
  consideração o tempo em que uma tarefa foi retornada. Assim, se ocorrer uma
  interrupção o tempo que a tarefa foi retornada não ira mudar, podendo criar
  assim uma tarefa com intervalos iguais de execução chamada de tarefa cíclica
  \item \textbf{uxTaskPriorityGet} - Método usado para informar prioridade de
  uma determinada tarefa
  \item \textbf{vTaskPrioritySet} - Método usado mudar a prioridade de uma
  determinada tarefa
  \item \textbf{vTaskSuspend} - Método usado para suspender uma determinada
  tarefa
  \item \textbf{vTaskResume} - Método usado retornar uma tarefa
\end{itemize}

\subsubsection{Utilitários de tarefas}
É atravé dessa biblioteca que o FreeRTOS diponibiliza para o usuário informações
importantes a respeito das tarefas e do escalonador do sistema . Nela estão
prensentes funcionalidades com a de retornar uma referência para a utual tarefa
em execução, retornar o tempo de funcionamento e o estado do escalonador e
retornar o número e a lista das tarefas que estão sendo gerenciadas pelo
sistema. Uma listagem das principais funcionalidades dessa biblioteca é
encontrada a seguir:

\begin{itemize}
  \item \textbf{xTaskGetCurrentTaskHandle} - Retorna a uma referência para
  atual tarefa em execução
  \item \textbf{xTaskGetTickCount} - Retorna o tempo decorrido desde a
  inicialização do sistema
  \item \textbf{xTaskGetSchedulerState} - Retorna o estado do escalonador 
  \item \textbf{uxTaskGetNumberOfTasks} - Retorna o número de tarefas do sistema
  \item \textbf{vTaskList} - Retorna uma lista de tarefas do sistema
\end{itemize}
\subsubsection{Controle do Escalonador}
Nessa biblioteca estão presentes as funcionalidades responsáveis por controlar
as atividades do escalonador do sistema. Nela encontramos funcionalidades
responsáveis por inicializar e finalizar as atividades do escalonador, assim
como, suspender e retornar a atividades do mesmo. As principais funcionalidades
presente nessa biblioteca são :

\begin{itemize}
  \item \textbf{vTaskStartScheduler} - Método que inicia as atividades do
  escalonador. Usado para a inicialização do sistema
  \item \textbf{vTaskEndScheduler} - Método que termina as atividades do
  escalonador. Usado para a finalização das atividades do sistema também 
  \item \textbf{vTaskSuspendAll} - Método que suspende as atividades do
  escalonador
  \item \textbf{xTaskResumeAll} - Método que retorna as atividades de uma
  escalonador suspenso
  
\end{itemize}

\section{Comunicação e sicronização entre tarefa}
Frequentemente tarefas necessitam se um com as outras. Por exemplo a tarefa A
depende da leitura do teclado feito pela tarefa B. Com isso a uma necessidade
de que está comunição sejá feita de maneira bem estruturada e sem interrupções.
Devido a isso a maiorida dos sistemas operacionais oferencem vários tipos de
comunicação entre as tarefas. Que podem ocorrer da seguinte forma: uma tarefa
deseja passar informações para outra, duas ou mais tarefas querem utilizar o
mesmo recurso e uma tarefa dependo do resultado produzido por outra tarefa.

No FreeRTOS assim como na maioria dos sistemas operacionais os mecanismos
responsáveis pela a comunicação entre as tarefas são a fila de mensagem, o
semáforo e o mutex (Mutal Excluision). Para entender melhor como funciona a
comunicação entre tarefas no FreeRTOS, cada um desses mecanismo será detalhado
a seguir

\subsection{Fila de Mensagens}

Filas de mensagens são estruturas primitivas de comunicação entre tarefas. Elas
funcionam como, demonstra a figura \ref{fig:fila_de_mensagens}, um túnel no qual
tarefas enviam e recebem mensagem. Assim quando uma tarefa necessita comunicar-se
com outra primeiramente ela envia uma mensagem para o túnel para que a outra
tarefa, quando entrar em execução possa ler a mensagem enviada.
 

\begin{figure}[!h] \centering
\includegraphics[scale=0.6]{../fig/croutine_states.jpg}
\caption{Funcionamento de uma fila de mensagens}
\label{fig:fila_de_mensagens}
\end{figure} 
 
 
No FreeRTOS, uma fila de mensagens é formada por uma lista de tamanho fixo que
armazena as mensagens,também de tamanhos fixos, enviadas para a lista. Assim,
quando uma mensagem é envida para uma fila, uma cópia dela é armazenada na lista
de mensagens para que outra tarefa possa utiliza-la. Entranto, no lugar de copiar
toda mensagem para a lista de mensagens, é possível também armazenar-se apenas
uma referência para a mesma, o que torna mais complicado um trabalho do
desenvolvedor, pois assim o acesso à mensagem ficará compartilhado entre as
tarefas, necessitando com isso de uma estrutura de sicronização para coordenar a
utilização da mensagem pelas tarefas.

Além da lista de mensagens uma fila de mensagens é composta por mais duas
outras lista, uma para armazenar as tarefas que estão aguardando enviar uma
mensagens para a fila e outra para armazenar as tarefas que estão aguardando
receber uma mensagem da fila. Assim, quando uma tarefa tenta enviar uma
mensagem para uma fila cheia esta é bloqueada e colocada na lista de tarefa
aguardam para enviar uma mensagem para fila até que um lugar na fila sejá
liberado. O mesmo acontece quando uma tarefa tenta ler uma mensagem de uma fila
vazia.

O FreeRTOS, disponibiliza para o usuário funcionalidades é possíveis de definir o
tempo máximo que uma tarefa pode ficar bloqueada esperado por uma fila (liberação
de espaço ou chega de mensagem). E no caso em que existem mais de uma tarefa
bloqueadas aguardando por um evento de uma fila, as tarefas de maior prioridade
têm preferência sobre as demais.

\subsection{Semáforo}
Semáforos são mecanismos usados na sincronização entre tarefas. Eles funcionam
como uma chave que libera, ou não, o uso de um determinado recurso. Assim quando
uma tarefa deseja acessar um recurso compartilhado, ela primeiramente deve
solicitar o semáforo que coordena o uso do recurso, caso o semáforo esteja
liberado, a tarefa tem a permissão de utilizar o recurso e, em seguida, libera o
semáforo, caso contrário, a tarefa é bloqueada até que o semáforo seja liberado.

O FreeRTOS disponibiliza dois tipo de semáforos: os semáforo binário e o semáforo
de contador. A diferença entre os dois está apenas no número de tarefas que podem
reter o semáforo ao mesmo tempo. No semáforo binario apenas uma tarefa pode reter
o semáforo e acessar o recurso compartilhado. E no semáforo com contador existe
um número fixo de tarefa que podem reter o semáforo, sendo esse número definido
na criação do semáfor e controlado pelo contador. Assim no semáforo com contador
para cada tarefa que retem o semáforo o contador é decrementado de um e para cada
tarefa que libera o semáforo o contador é incrementado, sendo que o semáforo
torna-se indisponível quando o contador for igual a zero.

No FreeRTOS o semáforo binário funciona como uma fila de mensagens com um único
item. Assim, quando a fila estiver vazia, indica que o semáforo está sendo usado
e, quando a fila estiver cheia, indica que o semáforo está liberado. O mesmo
ocorre para o semáforo com contador, só que nesse caso, o tamanho da fila será a
quantidade de tarefas que podem reter o semáforo ao mesmo tempo.

\subsection{Mutex}

Mutex são parecidos com o semáforo binário. A única diferença entre os dois é que
o mutex implementa um mecanismo de herança de prioridade, o qual impede que uma
tarefa de maior prioridade fique bloqueada a espera de um semáforo ocupado por
uma tarefa de menor prioridade, causando o que chamamos de inversão de
prioridade.

O mecanismo de herança de prioridade funciona da seguinte forma, quando uma
tarefa solicita o semáforo ele verifica se a tarefa solicitante possui prioridade
maior que a tarefa com o semáforo. Caso afirmativo, a tarefa que retém o semáforo
tem, momentaneamente, a sua prioridade elevada, para que assim ela possa realizar
a suas funções sem interrupções e, conseqüentemente, liberar mais rapidamente o
semáforo.

\subsection{Bibliotecas}
A característica de comunicação e sicronização entre tarefas está dividida em
duas bibliotecas, Gerenciamento de fila de mensagens e Semáforo/Mutex. A seguir
tem-se a explicação de cada uma dessas bibliotecas.

\subsubsection{Gerencialmente de fila de Mensagens}
A biblioteca gerenciamento de fila de mensagens é responsável pela criação e
utilização da estrutura fila de mensagens. Ela é composta por funcionalidades que
instanciam e removem fila de mensagens do sistema assim como também
funcionalidades que enviam/recebem mensagens para/de uma fila de mensagens
desejada. Abaixo tem-se uma lista com as principais funcionalidades dessas
biblioteca.

\begin{itemize}
  \item \textbf{xQueueCreate} - Cria uma instância de uma nova fila de
  mensagens no sistema
  \item \textbf{vQueueDelete} - Remove uma fila de mensagem do sistema
  \item \textbf{xQueueSend} - Envia um mensagem para a fila 
  \item \textbf{xQueueSendToBack} - Envia uma mensagem para o fim da fila  
  \item \textbf{xQueueSendToFront} - Envia uma mensagem para o inicio da fila
  \item \textbf{xQueueReceive} - Ler e remove uma mensagem da fila 
  \item \textbf{xQueuePeek} - Apenas ler uma mensagem da fila
\end{itemize}

\subsubsection{Semáforo/Mutex}
Na biblioteca de semáforo e mutex são implementadas as características de
sicronização entre tarefas, ou seja, os mecanísmo de semáforo e mutex junto com
as suas operações. Assim nessa biblioteca estão presentes funcionalidades que
criam e removem semáforos e mutex, além das funcionalidades que solicitam e
liberam os semáforos e os mutex. As principais funcionalidades dessa biblioteca
pode ser vista a seguir.


\begin{itemize}
  \item \textbf{vSemaphoreCreateBinary} - Cria um semáforo binário
  \item \textbf{vSemaphoreCreateCounting} - Cria um semáforo com contador 
  \item \textbf{xSemaphoreCreateMutex} - Cria um mutex 
  \item \textbf{xSemaphoreTake} - Solicita a retensão de um semáforo ou de um
  mutex
  \item \textbf{xSemaphoreGive} - Libera um semáforo ou um mutex retido
\end{itemize}


\section{Criação de uma aplicação utilizando o FreeRTOS}

Para construir uma aplicação de tempo real utilizando o FreeRTOS o desenvolvedor
deve seguir determinadas restrições imposta pelo sistema operacional
possibilitando o correto funcinamento da aplicação desenvolvida. Alguma dessa
restrições são restrições de configuração e modelos de criação de tarefa e fila
de mensagem. Assim com o intuido de ajudar o desenvolvedor a criar suas
primeiras aplicações O FreeRTOS disponibiliza em seu código fonte aplicações
exemplos divididas em cada uma das plataforma alvo que o FreeRTOS suporta.

Entretanto, a criação e analise é uma atividade que necessita conhecimento
maior do funcionamento e funcionalidades do FreeRTOS, fugindo assim o objetivo
geral desse capitulo que é proporcionar ao leitor uma breve introdução ao
FreRTOS. Assim para efeito de fixação exemplificação das funcionalidades
apresentadas aqui necesse capítulo será demonstrado de forma ditática (abstrata)
como é criada uma aplicação no FreeRTOS, concentrando principalmente na criação
de tarefas e fila de mensagen, pois a utilização das demais funcionalidades
assemelham-se bastante com essas.

\subsection{Criação de tarefas}
As tarefas são as partes mais importantes de um aplicação é nela onde são
colocadas as rotinas que realizam as funcionalidades de uma aplicação. No
FreeRTOS as rotinas de uma tarefa devem seguir um determinado modelo
demonstrado a seguir.

modelo de uma rotina de uma tarefa

Após se criada um tarefa é necessário que essa seja cadastrada no Sistema
Operacional, ou seja, a tarefa deve ser adcionada ao FreeRTOS. Esse trabalho é
feito através da funcionalidade <<nome\_da\_funcionalidade>> (<<seção da
funcionalidade>>), demonstrado na figura XXX. Nela é onde são identificados todos
os parâmentros que compõem uma tarefa como prioridade, no exemplo <<prioridade>>,
tamanho da pila, <<xxx>> no exemplo e demais parâmetros como nome e  XXX. Ao ser
criada uma tarefa irá possuir o estado pronto, podendo a mesma mudar seu estada
imediatamente para em execução dependendo de sua prioridade.

Assim aplicação completa que define, cria e inicia a execução de uma tarefa é
mostrada na figura XXX. Nela perecebe-se ainda a presença da funcionalidade XX
usada para iniciar as atividades do escalonador e conseguentemente a do sistema.

\subsection{Criação de filas de mensagem}

Do mesmo mode que uma tarefa, a criação de uma fila de mensagem deve seguir o
modelo determinado pelo FreeRTOS

\subsection{Criação de semáforos}

Do mesmo mode que uma tarefa, a criação de uma fila de mensagem deve seguir o
modelo determinado pelo FreeRTOS





\chapter{Método B}

Métodos Formais trata-se de uma abordagem formal para a especificação e
construção de sistemas computacionais. Eles utilizam-se de conceitos
matemáticos sólidos como lógica de primeira ordem e teorias dos conjuntos para
a criação e verificação de sistemas consistentes, seguros e sem ambiguidades.
Devido a sua rigosa construção os métodos formais tem sido bastante utilizados
na criação de sistemas críticos como industria aeronaltica, programas médicos e
programas lidam enormes valores monetários.

O método B trata-se de uma abordagem formal usado para especificar e construir
sistema computacionais seguros. Ele foi criado por Jean-Raymond Abrial, com a
colaboração de outros pesquisadores da universidade de Oxford. Na sua criação
foram reunidaes várias qualidades presentes nos demais método formais. Entre elas
estão as pré e pós condições, condições necessárias para a execução de um método
e alcançadas após a execução do mesmo, mudularização, abstração e refinamento,
estratégia de construção/especificação de sistemas através de vários níveis de
abstração.

%o método B proporciona uma criação de sistemas através de sucessiveis níveis de
%abstração, na qual inicialmente cria-se um modulo abstrato em uma linguagem de
%modelagem. Esse módulo é refinado através de vários outros módulos até chegar
%em uma linguagem algorítmica, denominada B0, que pode ser traduzida
%automaticamente em algumas linguagem de programação imperativa com C, Ada,
%Java, JavaCard e C\#.

%Cada módulo criado no desenvolvimento do sistema com o método B deve ser
%analisado estaticamente para saber se ele é implementável ou consistente, ou
%seja, que sua execução não leve a um estado não permitido pela especificação.
%Assim como também cada nível de abstração deve ser analisado estaticamente para
%saber se ele é coerente com o nível acima.

\section{Etapas do desenvolvimento em B}

O processo de desenvolvimento através do método B inicia-se com um módulo que
define o modelo funcional de alto nível do sistema. Em B, esses módulos são
denominados de Máquina Abstrata (MACHINE). Nessa fase de modelagem técnicas
sémi-formais como UML podem ser utilizadas e em seguidas transfomadas para a
notação formal do método B. Após a criação dos módulos esse são analisados
estaticamentes para verificar se a sua especificação é coerênte e implementável.

Uma vez estabelicido um modelo abstrato incial do sistema, o método B permite que
seja construidos módulos mais concretos do sistema denominados refinamentos,
sendo que um refinamento deve está sempre associado a um modelo mais abstrato. Um
refinamento especifica uma decição de projeto que determina que partes das
modelagem do sistema devem ser especificado em um nível mais concreto. Assim,
para garantir a correta especificação de um refinamento este deve ser analisado
estaticamente afim de comprovar a sua conformidade com o nível abstrato associado
a ela.

Com isso sucessíveis refinamentos são realizados até que modelagem do sistema
adiquira um nível concreto o bastante para ser implementado. Nesse nível é criado
um nível especial de refinamento denominado implementação (IMPLEMENTATION). Nele
o nível de abstração da especificação assemelha se com a de uma linguagem
algoritmica sendo assim possível da implementação para código em linguagem de
programação como C, Java e JavaCard.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.9]{../fig/desenvolvimento_b.jpg}
\caption{Etapas de desenvolvimento de sistema atravé do método B}
\label{fig:desenvolvimento_b}
\end{figure}

Assim o desenvolvimento de sistemas utilizando o método B é feito como demonstra
a figura~\ref{fig:desenvolvimento_b}. Nela os requisitos do sistema são
especificados iniciandos em um nível abstrato e após sucessivos refinamentos um
nível concreto e algoritmico do sistema é alcançado. Em seguida é feita a sintese
da especificação para o código de linguagem de programação, sendo possível
apartir da especificação funcional inicial gerar teste para o sistema
desenvolvido. 

Atualmente o desenvolvimento de sistemas utilizando o método B pode ser apoiado
por diversas ferramentas que vão desde a analise estática da especificação até a
geração de código de linguagem de programação. Devido a isso, o método B
utrapassou a barreira acadêmica e passou a ser bastante difundido na indústria de
sistemas críticos, principalmente na industrias ferroviárias e automobilistica,
sendo utilizado em sistemas que atuam no metro de Paris e em subsistemas dos
automóveis da Peugeot. Nas próximas seções serão demonstrada as principais
etapas de desenvolvimento de um sistema utilizando o método B.


\section{Máquina Abstrata}

A base do método B está na notação de máquina abstrada(em inglês:
\textit{Abstract Machine Notation} - AMN) a qual disponibiliza um framework comum
para a especificação e contrução de sistemas, permitindo também a verificação
estática do mesmo.  Mais especificamente, a AMN trata-se de uma liguagem de
especificação de sistemas formada por moódulos básicos de construção chamados de
Máquina Abstrata ou simplemente Máquina.

Cada Máquina Abstrata é composta por diferentes seções, sendo que cada seção é
responsável por definir um aspecto da especificação do sistema como: parâmetros,
tipos, constantes, variáveis de estado, estados iniciais e transições do sistema.
Como, por exemplo, a figura~\ref{fig:maquina_kernel} contém uma Máquina
Abstrata, chamada \textit{Kernel}, a qual especifica um sistema que permite
incluir e excluir tarefas até o limite de 10 tarefas e possui as seguintes
seções:


\begin{description}
\item[MACHINE] Nessa seção inicia-se
o código da máquina abstrata. Ela identifica a natureza e o nome do módulo,
seguido opcionalmente por um ou mais parâmetros separados por vírgula e
limitados por parenteses
\item[SETS] introduz um novo tipo de entidade, no exmplo é
  $\mathit{TASK}$. Nesse momento, nenhum detalhe é fornecido quanto à
  maneira como essa entidade será implementada.
\item[VARIABLES] informa o nome das diferentes variáveis que compoem o estado.
No exemplo, apenas há uma variável de estado: $\mathit{tasks}$.
\item[INVARIANT] especifica o tipo das variáveis de estado assim
  também como os estados válidos do sistema. Aqui, $\mathit{tasks}$ é
  um conjunto de até 10 elementos do tipo $\mathit{TASK}$. A
  caracterização lógica do conjunto dos estados válidos é uma das
  atividades mais importantes da especificação.
\item[INITIALISATION] identifica quais são os possíveis estados
  iniciais do sistema. No caso, $\mathit{tasks}$ é o conjunto vazio.
\item[OPERATIONS] determina os diferentes tipo de eventos que o
  sistema pode sofrer. No nosso exemplo, temos operações para
  adicionar e eliminar um elemento de $\mathit{tasks}$. Uma operação
  pode ter parâmetros, resultados e pode alterar o valor de variáveis
  de estado. Um ponto importante encontrados nas operações são as précondições,
  a quais são condições que devem ser satisfeitas para que a operaçõas seja
  realizada
\end{description}  
\begin{figure}[!ht]
\begin{small}

$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\MACHINE\\
\quad \mathit{Kernel}\\
    
\SETS\\
\quad \mathit{TASK}\\
    
\VARIABLES\\
\quad \mathit{tasks}\\
    
\INVARIANT\\
\quad \mathit{tasks} \in \pow(\mathit{TASK}) \land \\
\quad \card(\mathit{tasks})\leq 10\\
    
\INITIALISATION\\
\quad \mathit{tasks}:=\emptyset\\
    
\end{array}
\begin{array}[t]{l}
\OPERATIONS\\\\
\mathit{task\_add}(\mathit{task}) = \\
\quad \PRE \\
\quad\quad \mathit{task}\in \mathit{TASK} \land \\
\quad\quad \mathit{task}\not\in \mathit{tasks} \land\\
\quad\quad \card(\mathit{tasks})<10\\
\quad \THEN\\
\quad\quad \mathit{tasks}:=\mathit{tasks}\cup \{\mathit{task}\}\\
\quad   \END;\\

\end{array}

\begin{array}[t]{l}
\ldots\\
\mathit{task\_delete}(\mathit{task})=\\
\quad \PRE\\
\quad \quad \mathit{task}\in \mathit{tasks}\\
\quad \THEN\\
\quad \quad \mathit{tasks}:=\mathit{tasks}-\{\mathit{task}\}\\
\quad \END\\
	
\END\\
\end{array}
\end{array}
$$
\end{small}
\caption{Maquina abstrata de tarefas}
\label{fig:maquina_kernel}
\end{figure}

Com isso a especificação de sistemas utilizando o método B pode ser dividido em
duas partes principais, a especificação do estado da máquina e a especificação
das operações da máquina. Essas duas partes serão discutidas a seguir.

\subsection{Especificação do estado dá máquina}
O estado de uma máquina abstrata pode ser definido em termos de suas variáveis
e do seu invariante. Assim o estado de uma máquina é formado pelas as variáveis
da máquina junto com suas definições e limitações. É no estado que é defino os
estado válidos do sistema. 

No estado da máquina são especificados, por meio de calculo de predicados, da
teoria do conjunto e relações, as propriedades estáticas que o sistema deve
obedecer. Assim no exemplo da figura~\ref{fig:maquina_kernel} o estado foi
especificado como sendo a variável $\mathit{tasks}$ e seu predicados
$\mathit{tasks} \in \pow(\mathit{TASK})$ e $ \card(\mathit{tasks})\leq 10$

\subsection{Especificação das operações da máquina}

Nas operações da máquina é especificado o comportamento dinâmico do sistema. É
através das operações que o estado da máquina é alterado, respeitando sempre as
restrições do estado da máquina, ou seja, as codições declaradas no invariante
dá máquina deve ser sempre satisfeita no final da operação.

O cabeçalho de uma operação é composto por um nome, uma lista de parâmetro de
entra e uma lista de parâmentro de saida \footnote{A notação de máquina abstrata
permite que uma operação retorne mais de um parâmetro}, sendo que os parâmetro de
entrada e os parâmetros são argumentos opcionais. Assim o exemplo mais completo
de uma operação pode ser visto na figura~\ref{fig:query_task}, a qual o nome da
operação é $\mathit{query\_task}$, o parâmetro de entrada é $\mathit{task}$ e o
parâmetro de saida é $\mathit{belong}$.

A operação propriamente dita é formada por pré-condição e corpo da operação. Na
pré-condição, são colocadas as informações sobre todos os parâmetros de entrada
da operação e as condições que devem ser satisfeitas para que a operações sejá
execultada. Com isso, a pré condição funciona como uma premissa que deve ser
satisfeita para que a operação funcione corretamente. 

Por exemplo, na figura~\ref{fig:maquina_kernel} para que a operação
$\mathit(add_task)$ funcione corretamente e não leve a máquina para um estado
inválido as pré-condições $\mathit{task}\in \mathit{TASK}$, $\mathit{task}\not\in
\mathit{tasks}$ e $\card(\mathit{tasks})<10$ devem ser obedecidas.

\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{ans}\leftarrow \mathit{query\_task}(\mathit{task}) =\\
\PRE
\quad \mathit{task} \in \mathit{TASK}\\
\THEN\\
\quad\quad \IF \quad \mathit{task} \in \mathit{TASK} \\
\quad\quad \THEN \quad ans := yes\\
\quad\quad \ELSE \quad ans:=no\\
\END
\end{array}
\end{array}
$$
\end{small}
\caption{Operação que consulta se uma tarefa pertece a máquina
$\mathit{Kernel}$}
\label{fig:query_task}
\end{figure}
No corpo da operação é especificado o seu comportamento. Nele os parametros de
saida são obrigatoriamente valorados e os estados da máquina são alterado ou
consultados. Assim, para realizar essas atualizações de modo formal a notação
de máquina abstrata possui um conjunto de atribuiçoes abstratas, denominadas
substituições, que possuem regras de como tal atribuições é realizada, o que
permite uma analise estática da operações em realação a consistência da máquina.
A seguir são demonstradas algumas das principais substituições da AMN.


\subsubsection{Substituição Simples}

A substituição simples é definida da seguinte forma: $$\mathit{x}:= \mathit{E}$$
Nela $\mathit{x}$ trata-se a variável ou parâmentro de saida, para o qual será
atribuido o valor da expressão $\mathit{E}$. Mais precisamente uma substituição é
interpreta da seguinte maneira $$[\mathit{x}:=\mathit{E}]\mathit{P}$$ Assim
tem-se que o predicado $\mathit{P}$ deve ser mantido quando a variável
$\mathit{x}$ for substituida por $\mathit{E}$. Por exemplo na operação
$\mathit{add_task}$ a substuição $\mathit{tasks}:=\mathit{tasks}\cup
\{\mathit{task}\}$ pode ser vista como $[\mathit{tasks}:=\mathit{tasks}\cup
\{\mathit{task}\}] \card(\mathit{tasks})<10$, Na qual $\card(\mathit{tasks})<10$
é o predicado, no caso o invariante da máquina, que deve ser obdecido quando a
substituição for realizada, ficando ao final $\mathit{tasks}\cup
\{\mathit{task}\}<10$

\subsubsection{Substituição Multipla}

A substituição multipla trata-se de uma generalização da substituição simple. Ela
permite que várias variáveis seja atribuidas simutaneamente. Assim uma
substituição multipla utilizando duas variável tem a seguinte forma:
$$\mathit{x},\mathit{y}:=\mathit{E},\mathit{F}$$ Onde paras variáveis
$\mathit{x}$ e $\mathit{y}$ são atribuido os valores das exepressõe $\mathit{E}$
e $\mathit{F}$, respectivamente. Assim da mesma forma que a substituição simples,
a multipla substituição é definida da seguinte maneira:
$$[\mathit{x}:=\mathit{E},\mathit{y}:=\mathit{F}]\mathit{P}$$ Na qual
$\mathit{P}$ é o predicado que deve ser verdadeiro quando suas variáveis
$\mathit{x}$ e $\mathit{y}$ forem substituidas por $\mathit{E}$ e $\mathit{F}$,
respectivamente. Por exemplo, uma máquina que possui o predicado
$\mathit{x}<\mathit{y}$ e possui a seguinte substituição $\mathit{x},\mathit{y}
:=\mathit{x}+10,\mathit{y}+5$ é redizida a seguinte forma $[\mathit{x},\mathit{y}
:=x+10,y+5]\mathit{x}<\mathit{y}$, o que resulta em $\mathit{x}+10<\mathit{y}+5$

\subsubsection{Substituição Condicional}

As substituições simples e multiplas permitem somente um opção de especificação
onde uma atribuições é sempre feitas de maneira uniforme sem opções e sem levar
consideração os estados iniciais na operação. Entretanto, as linguagens de
programação convencionais disponibilizam um tipo condicional de atribuição na
qual é permitido caminhos diferente de acordo com expressões lógicas que utilizam
o valores iniciais das variáveis do sistema. Esse tipo de atribuição é
feita através da formação $\IF$ $\THEN$ $\ELSE$.

Assim como nas liguangens de programação, a notação de máquina abstrata também
permite a construção de atribuições condição, as quais são feitas através da
substituição condicional. Com isso, uma substituição condicional funciona da
mesma forma que as linguagens de programação, não qual uma expressão lógica é
avaliada para saber qual caminha a estrutura deve seguir, e qual atribução deve
ser realizada. A forma como é especificada uma substituição condicional na ANM
pode ser visto a seguir:

$$\IF \quad \mathit{E}\quad \THEN\quad \mathit{S}\quad \ELSE\quad \mathit{T}$$

NA especificação acima $\mathit{S}$ e $\mathit{T}$ são substituições tem suas
execuções condicionadas pela exepressão lógica é $\mathit{E}$, na qual pode
conter variáveis da máquina como também os parâmetros de entrada da operação. Com
isso, caso $\mathit{E}$ sejá afirmativo a substituição $\mathit{S}$ é realizada
e caso ele seja negativo a substituição $\mathit{T}$ é executada. Assim a
substituição condicional pode ser interpretada da seguinte forma:

$$[\IF \quad \mathit{E} \quad \THEN \quad \mathit{S} \quad \ELSE
\quad \mathit{T}] \mathit{P} \quad = \quad (\mathit{E} \Longrightarrow
[\mathit{S}] P )\land (\neg\mathit{E} \Longrightarrow [\mathit{T}] P)$$.

Um exemplo simples da utilização dessa substituição pode ser visto na
figura~\ref{fig:query_task}. Nela a expressão $\mathit{task} \in \mathit{TASK}$ é
primeiramente analisada para decidir qual substituição simples deve ser
execultada. Caso a o resultado da expressão sejá afirmativo $\mathit{ans} :=
\mathit{yes}$ é execultado e caso a expressão sejá negativa $\mathit{ans} :=
\mathit{no}$ é execultado.
 
\subsubsection{Substituição não deterministica $\ANY$}
Até agora foram vista apenas substituições deterministacas, ou sejá elas possuem
um comportamento previsível que leva a apenas um resultado final é possível.
Entretanto, as máquinas abstratas de B servem para fazer especificação abstrata
de sistemas e componetes e as vezes em certo nível de abstração o comportamento
das operações do sistema podem não ser tão previsíveis como as substituições
deterministicas exigem. Para resolver esse problema foram criadas as
substituições não deterministicas

As substituições não deterministicas tratam-se de substituições que introduzem
escolhas aleatórias no corpo das operações, levando a mesma não mais para um
estado final previsível e sim para um conjunto de estados finais possíveis. Assim
para uma determinada escolha a especificação apenas define em qual conjunto deve
ser feita a escolha e não diz nenhuma informação de como tal escolha deve ser
feita.

Um exemplo de substituição não deterministica da AMN é a substituição $\ANY$.
Essa substituição possui o seguinte formato:  
$$\ANY\quad\mathit{x}\quad\WHERE \quad\mathit{Q}\quad\THEN\quad\mathit{T}\quad\END$$

Através da especificação assim percebe-se que a substituição $\ANY$ é formada
por três elementos:

\begin{description}
\item[$\mathit{x}$]trata-se de uma lista de variável que será utilizada no
corpo da substituição e para as quais serão escolhidos valores abstratos
delimitados pelo o predicado $\mathit{Q}$.
\item[$\mathit{Q}$] são predicados que delimitam o conjunto de opções para as
variáveis $\mathit{x}$. Nessa parte as variáveis $\mathit{x}$ devem
obrigatoriamente serem tipificadas.
\item[$\mathit{T}$] é denominado corpo da substituição. Nele são colocados
atribuições que utilizam-se das variáveis $\mathit{x}$ para atualizar estados
ou atribuir valores para os parâmetros de saida de uma operação
\end{description}

Um exemplo da substituição $\ANY$ pode ser visto na
figura~\ref{fig:random_create} naqual uma tarefa aleatória a adicionada na
máquina $\mathit{Kernel}$. Nela primeiramente a variável $\mathit{task}$ é criada
para qual será atribuido um valor aleatório. Em seguida, tipo e uma restrição
sobre $\mathit{task}$ é definida. Por ultimo a variável $\mathit{task}$ é
adicionada ao conjunto $\mathit{tasks}$. Assim um comportamento não
deterministico é atribudo a operação pois para cada execução da operação a
variável $\mathit{task}$ pode assumir um valor aleatório.
 

\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{random\_create}=\\
\PRE\\
\quad\card(\mathit{tasks})<9 \\
\THEN\\
\quad \ANY \\
\quad\quad \mathit{task}\\
\quad \WHERE \\
\quad\quad \mathit{task}\in \mathit{TASK} \land\\
\quad\quad \mathit{task} \not\in \mathit{tasks}\\
\quad \THEN\\
\quad\quad \mathit{tasks}:=\mathit(tasks)\cap \mathit{task}\\
\quad \END\\


\END
\end{array}
\end{array}
$$
\end{small}
\caption{Operação que cria uma tarefa aleatória na máquina
$\mathit{Kernel}$}
\label{fig:random_create}
\end{figure}

Uma definição para a substituição $\ANY$ seria: $$\forall \mathit{x}.(Q
\Rightarrow [\mathit{T}]P)$$ Indicando que para todo valor que for escolhido para
o conjunto de variável $\mathit{x}$ as substituições $\mathit{T}$ devem garantir
o predicado $\mathit{P}$.

\section{Obrigação de Prova}

Após a criação de uma máquina abstrata utilizando o método B essa deve ser
avaliada estaticamente para saber se a mesma é coerente e passível de
impementação. Para realizar tal análise o método B dispoem de um conjunto de
obrigações de prova que são asserções criadas apartir da especificação de uma
máquina abstrata e que devem provadas afim a corretude da especificação.

Resulmidamente a analise estática de uma máquina abstrata através das obrigações
de prova avalia se essa possui estados válidos, ou seja, se pelo menos uma
combinação de estados válidos é alcançada pela máquina e, caso afirmativos, se
esses são mantidos pelos invariantes. Com isso as principais obrigações de prova
gerada em uma máquina abstrata saõ: Consistência do Invariante, Obrigação de
Prova da Inicialização e Obrigação de Prova das Operações. A seguir é detalhado o
que significa cada uma dessas obrigações de prova e como elas são realizadas.

\subsection{Consistência do Invariante}
Nessa obrigação de prova é analisado se o invariante da máquina possui pelo
menos uma combinação naqual todos os estados são válidos. Assim essa obrigação
de prova é definida da seguinte maneira :
 
$$\exists\mathit{v}.\mathit{I}$$ 

Onde $\mathit{v}$ indica o vetor de todos as variáveis da máquina e $\mathit{I}$
representa o Invariante da máquina. Com isso, a definição acima pode ser
entendida como: Deve existir pelo menos um valor para o vetor de variáveis
$\mathit{v}$ que satisfaça o invariante

Um exemplo da aplicação desse obrigação de prova na máquina da
figura~\ref{fig:maquina_kernel} seria: 

$$\exists \mathit{tasks}.(\mathit{tasks} \in \mathit{TASK} \cap
\card(\mathit{tasks})\leq 10 $$

O que pode ser provador como verdadeiro para $\mathit{tasks} = \emptyset $


\subsection{Obrigação de prova da inicialização}
Outro obrigação de prova necessária para uma máquina abstrata é saber se seu
estado inicial satisfaz o invariante. Em outras palavras significa verificar se
o estado inicial da máquina é um estado válido. Assim essa obrigação de prova é
definida da seguinte maneira :
$$\mathit[T]\mathit[I]$$

Nela $\mathit[T]$ indica as substituições realizadas na inicialização da máquina
e $\mathit[I]$ indica os predicados definidos no invariante. Assim a obrigação de
prova da inicialização da máquina da figura~\ref{fig:maquina_kernel} pode ser
definido como sendo:

$$[\mathit{task}:= \emptyset] (\mathit{tasks} \in \mathit{TASK} \cap
\card(\mathit{tasks})\leq 10) \quad \Rightarrow\quad \emptyset \in \mathit{TASK}
\cap \card(\emptyset)\leq 10 $$

O que pode ser facilmente visto como uma verdade.


\subsection{Obrigação de prova das Operações}
Na obrigação de prova das operações deve ser analisado se, quando satisfeita a
sua pré-condição, a execução da operação levará a máquina a um estado válido.
Assim a definição dessa obrigação de prova pode ser vista da seguinte maneira:

$$\mathit{I} \land \mathit{P} \Rightarrow [\mathit{S}]I$$

Na definição acima $\mathit{I}$ representa o invariante da máquina, $\mathit{P}$
representa a pré-condição da operação analisada e $\mathit{S}$ indica as
substituições realizadas no corpo da operação. Assim, uma explicação mais precisa
desa definição serai que quando a máquina estiver em um estado válido e a
pré-condição da operação for satisfieta, a execução da operação deve manter a
máquina em um estado válido. Nota-se assim que essa obrigação de prova não
torna-se necessário ser avaliada para as operações que não alteram o estado da
máquina, chamada operções de consulta como a da figura~\ref{fig:query_task}, onde
apenas o valor da parâmentro de retorno é alterado.

Um exemplo de uma obrigação de prova da operação $\mathit{add_task}$ da máquina
da figura~\ref{fig:task_states} pode ser visto a seguir:

$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
(\mathit{tasks} \in \mathit{TASK} \land
\card(\mathit{tasks})\leq 10) \land 
(\mathit{task}\in \mathit{TASK} \land \mathit{task}\not\in \mathit{tasks})
\Rightarrow \\
([\mathit{tasks}:=\mathit{task}\cap\mathit{task}]((\mathit{tasks}
\in \mathit{TASK} \cap \card(\mathit{tasks})\leq 10))))
\end{array}
\end{array}
$$
 

\section{Refinamento}

A linguagem abstrata demonstratada até agora é usada para criar uma modelagem
funcional de sistemas e componentes. Nela o principal objetivo é descrever o
comportamento do sistema sem se preocupar com detalhes de como as informações
serão manipuladas pelo computador. Entretanto, para realizar uma modelagem mais
concrete e passível de implementação é necessário que notações matemáticas
abstratas utilizadas na modelagem abstratado sistema como conjutos e não
determinismo sejam descritas de forma mais concreta. Assim um sistema pode ser
desenvolvido gradativamente, nos quais os estágios intermidiários entre a
modelagem abstrata e a implementação, são combinações de especificações da
construção e detalhes de implementação denominado refinamento.

Refinamentos são decisos de projeto nas quais estruturas abstratas são detalhadas
em um nível mais concreto. Com isso, um refinamento deve obrigatorialmente está
ligado ao nível mais abstrato realizando as mesmo funcionalidades que este, só
que um nível menos abstrato. Para garantir que essa ligação sejá realizada de
forma correte existem mecânismo de analise estática denominados obrigações de
prova do refinamento

A construção de um refinamento é muito parecida com a construção de uma máquina
abstrata. Ele, assim como a máquina abstrata, é dividos em seções onde são
especificadas as informações do sistema, possuindo basicamente as mesma seção de
uma máquina abstrata. A diferenteça está na seção $\REFINEMENT$ onde é coloca o
nome do refinamento e na seção $\REFINES$ informa qual á máquina ou refinamento,
será refinado. Além disso assim como a construção de uma máquina abstrata pode
ser dividida em especificação do estado e especificação das operações, a
construção um refinamento pode ser dividido refinamento dos estados e
refinamentos das operações

\subsection{Refinamento do Estado}
No refinamento de dados, como é reconhecido o refinamento de estado, tem objetivo
de especificar o estado dá máquina de uma maneira mais concreta. Assim as
estruturas utilizadas na modelagem abstratas são especificadas de uma forma mais
próxima utilizada pelo computador. Para isso na especificação do refinamento seus
estados são criados de forma concreta e necessariamente esses devem possuir uma
ligação com os estados da máquina abstrata chamada de \textit{relação de
refinamento}

Por exemplo, a máquina $mathit{Kernel}$ da figura~\ref{fig:maquina_kernel} possui
o estado $\mathit{task}$ que um conjunto de elementos do tipo $\mathit{TASK}$. Um
possível refinamento desse estado é demonstrado pelo refinamento
$\mathit{KernelR}$ demonstrado na figura~\ref{fig:refinamento_kernelR}. Nele um
estado $\mathit{task}$ é refinado pelo variável $\mathit{taskR}$ que representa
uma sequência de tarefas, estrutura mais concreta do que um conjunto, sendo que a
relação entre os dois estados, \textit{realação de refinamento} é especificada na
preposição $\mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks}$.


\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{REFINEMENT}\\
\quad \mathit{Kernel\_r}\\
   
\REFINES\\
\quad \mathit{Kernel}\\
   
\VARIABLES\\
\quad \mathit{tasks\_r}\\
\end{array}

    

\begin{array}[t]{l}
\INVARIANT\\
\quad \mathit{tasks\_r} \in \mathbf{seq}(\mathit{TASK}) \land \\
\quad \mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks}\\
    
\INITIALISATION\\
\quad \mathit{tasks\_r}:=[]\\
\end{array}


\begin{array}[t]{l}
\OPERATIONS\\
\mathit{task\_add}(\mathit{task}) = \\
\quad \BEGIN\\
\quad \quad \mathit{tasks\_r}:=\\
\quad\quad\quad\quad\mathit{task} \to \mathit{tasks\_r}\\
\quad \END\\
    
\END
\end{array}

\end{array}
$$
\end{small}
\caption{Refinamento da maquina abstrata de $\mathit{Kernel}$}
\label{fig:refinamento_kernelR}
\end{figure}


\subsection{Refinamento das Operações}

Após feito o refinamento do estado da máquina é necessário agora especificar o
refinamento das suas operações. O refinamento das operações de uma máquina deve
garantir que está possua os mesmo comportamentos que suas operações abstratas,
podem até fazer menos ações que a abstrata, sendo proprido apenas as ações
adicionais.

As operações de um refinamento devem possuir a mesma assinaturas das operações da
máquina abstrata relacionada à ele, com os mesmo nomes e parâmetros de entrada e
saida. Entretanto, nas operações de um refinamento não é necessário a declaração
da pré condição $\PRE$, uma vez que essa foi definida em um nível mais abstrato e
são suficientes para garantir que o tipo do parâmetro de entrada permaneça o
mesmo e que o invariante da máquina seja mantindo quando a operação for
execultada.

Um exemplo do refinamento de uma operação pode ser visto na
figura~\ref{fig:refinamento_kernelR}, na operação $\mathit{add\_task}$. Nela
percebe-se a ausência da pré condição e que assinutura da operação permanece a
mesma. A parte alterada foi apenas o corpo da operação que agora foi adaptada
para trabalhar com o estado $\mathit{taskR}$.  

Um exemplo do refinamento da máquina $\mathit{Kernel}$
(figura~\ref{fig:maquina_kernel}) pode ser visto na
figura~\ref{fig:refinamento_kernelR}. Nela o conjunto de tarefas da máquina
$\mathit{Kernel}$ denominando $\mathit{task}$ é refinado como sendo uma sequência
de tarefas denominada $\mathit{taskR}$, o que é uma estrutura mais próxima da
implementação do que um conjunto. Assim as operações que utilizam-se dessa
estrutura também devem ser alteradas com o objetivo de mandar a compatibilidade
da operações com a nova representação do estado da máquina.

\subsection{Obrigação de Prova do refinamento}
A analise estática para saber se um refinamento e consistente com o nível
abstrato acima dele é feita através de geração de obrigações de prova e pode
ser dividida em das partes, obrigação de prova da inicialização e obrigação de
prova das operações. Entratanto, a obrigação de prova das operações dois
tratamentos possíveis, as obrigações de prova para as operações sem parâmentro
de retorno e a obrigação de prova para as operações com parâmetro de retorno. A
seguir é demonstrada como é realizada cadas umas dessas obrigações de prova.

\subsubsection{Obrigação de Prova da Inicialização}

Em um refinamento, a ligação entre os estados da máquina abstrata e o refinamento
é feito através do \textit{relação de refinamento} a qual será denomida de
$\mathit{J}$. Assim necessariamento a inicialização da máquina abstrata deve
possuir algum estado que satisfaça essa ligação, ou melhor dizendo, essa
$\mathit{J}$ deve possuir algum estado especificado pela inicialização de máquina
abstrata, denominada $\mathit{T}$. Isso gera a seguinte asserção: 

$$ \neg
[\mathit{T}] \neg \mathit{J} $$ 

O que define que $\mathit{T}$ deve possuir algum
estado válido em $\mathit{J}$, ou que, $\mathit{J}$ possui algum estado que
satisfaça a inicilização $\mathit{T}$.

Além disso é necessário também que a inicialização do refinamento denominado de
$\mathit{T1}$ esta liga a esse conjunto de estados válidos definidos por
$\mathit{J}$ e $\mathit{T}$. Essa ligação ocorre da seguinte forma, todo estado
gerado na inicialização de $\mathit{T1}$ deve possuir um correspondente válido
de $\mathit{T}$. Isso gera a seguinte definição

$$ [\mathit{T1}]\neg
[\mathit{T}] \neg \mathit{J} $$

Assim a obrigação de prova entre as máquina $\mathit{Kernel}$ e a máquina
$\mathit{KernelR}$ fica como desmonstra a asserção abaixo:

$$
[\mathit{tasks\_r}:=[]]\neg[\mathit{tasks}:=\emptyset]\neg(\mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks})
$$

\subsubsection{Obrigação de prova da operação sem parâmetro de retorno}
Geralmente uma operação é definada como $\PRE \mathit{P} \THEN \mathit{S} \END$
sendo o seu refinamento $\PRE \mathit{P1} \THEN \mathit{S1} \END$, onde na
maioria da vezes $\mathit{P1}$ é abstraído. Com isso, do mesmo modo que na
inicialização tem-se que os estado gerados em $\mathit{S1}$ devem estar
relacionado com alguma execução $\mathit{S}$, gerando:
 
$$\mathit{S1} \neg \mathit{S} \neg \mathit{J}$$

Entretando, diferente da inicialização a execução de uma operação deve levar em
consideração o estado da máquina anterior à sua realização. Com isso o estado
da máquina abstrata junto com o seu refinamento devem ser um estado válido. Uma
relevante ligação entre esse estados o invariante $\mathit{I}$ e a sua relação
de refinamento $\mathit{J}$. Além disso, para a correta execução da operação a
pré condição da mesma deve ser estabelecido. Assim, unido que uma operação só
pode ser executada corretamente quando à uma ligação válida entre os estado da
máquina e a sua pré condição for estabelicida, a obrigação de prova de uma
operação é feita da seguinte forma:

$$\mathit{I} \land \mathit{J} \land \mathit{P} \Rightarrow \mathit{S1} \neg
\mathit{S} \neg \mathit{J}$$

Por exemplo, a obrigação de prova do refinamento da operação
$\mathit{add_task}$ da máquina Kernel pode é estabelicida como de acordo com a
preprosição abaixo:


$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
(\mathit{tasks} \in \pow(\mathit{TASK}) \land \card(\mathit{tasks})\leq10)\land \\ 
\mathit{tasks\_r})=\mathit{tasks}  \land \\
\mathit{task}\in \mathit{TASK} \land \\
\mathit{task}\not\in \mathit{tasks} \land\\
\card(\mathit{tasks})<10 \Rightarrow 
[\mathit{tasks}:=\mathit{tasks}\cup \{\mathit{task}\}] \\
\neg[\mathit{tasks\_r}:= \mathit{task} \to \mathit{tasks\_r}] \\
\neg (\mathit{tasks\_r})=\mathit{tasks})
\end{array}
\end{array}
$$

\subsubsection{Obrigação de prova da operação com parâmetro de saida}

As operações com parêmetros de saida necessitam de uma atenção especial devido a
obrigação de que cada saiada possível para o refinamento deve está ligada a uma
saida da especificação abstrata. Assim denominando $\mathit{out'}$ como sendo os
parâmetros de saida do refinamento e $\mathit{out}$ os parâmentros de saida da
especificação diz-se que cada valor de $\mathit{out'}$ deve possuir um
correspondente em $\mathit{out}$. Em outra palavra, cada execução de
$\mathit{S1}$ deve encontrar uma $\mathit{S}$, naqual $\mathit{out'}$ produzido
por $\mathit{S1}$ sejá igual ao $\mathit{out}$ produzido por $\mathit{S}$.

Além da ligação entre o parâmetros de saída, a obrigação de uma operação com
retorno também deve obedecer todas as retrições impostas para as obrigações de
prova das operações sem parâmetro de saida, ficando da seguinte maneira:

$$\mathit{I} \land \mathit{J} \land \mathit{P} \Rightarrow
\mathit{S1}[\mathit{out'}/\mathit{out}] \neg \mathit{S} \neg \mathit{J}$$

Nela $[\mathit{out'}\mathit{out}]$ significa que na atribuições de $\mathit{S1}$
os valores de $\mathit{out}$ devem ser substituidos por $\mathit{out'}$ e manter
verdadeira a preposição, garantindo que cada produção de $\mathit{out}$ de
$\mathit{S1}$ tenha uma correspondente no conjunto $\mathit{out}$.



%\begin{itemize}
%  \item Explicar o que é o método B
%  \item Explicar a base teórica de B (AMN e as substituições)
%  \item Explicar como é especificado um sistema em B (como é criado um módulo)
%  \item Falar das obrigações de prova
%  \item Falar dos mecânismo de composição e refinamento
%  \item Dizer que o refinamento pode chegar em um nível concreto que pode ser
%  sintetizado para algumas linguagens de programação.
%  \item Falar do uso de ferramentas
%  \item Falar do projeto B2ASM
%\end{itemize}

\chapter{Revisão Literária}

 \begin{itemize}
  \item Enumerar Projetos
  \item Desafio de software verificado    
 \end{itemize}







\chapter{Proposta}

\begin{itemize}
  \item Como será feita a modelagem do FreeRTOS
  \item Falar do estudo do FreeRTOS e identificação dos seus principais
  conceitos e funcionalidades
  \item O desenvolvimento progressivo acrescentando novas funcionalidades a cada
  refinamento
  \item Ligar a abordagem do compilador verificável ao FreeRTOS
  \item Dizer como será ou deve feita a união do FreeRTOS para o compilador
  verificável
\end{itemize}

\chapter{Atividades e Etapas}

\newpage

\bibliographystyle{abnt-alf}
\bibliography{quali}

\anexo

\end{document}

